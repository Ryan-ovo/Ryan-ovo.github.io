<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Ryan-ovo.github.io</id>
    <title>Gridea</title>
    <updated>2021-04-21T09:47:02.348Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Ryan-ovo.github.io"/>
    <link rel="self" href="https://Ryan-ovo.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://Ryan-ovo.github.io/images/avatar.png</logo>
    <icon>https://Ryan-ovo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[[题解]LeetCode91.解码方法]]></title>
        <id>https://Ryan-ovo.github.io/post/solution-leetcode91/</id>
        <link href="https://Ryan-ovo.github.io/post/solution-leetcode91/">
        </link>
        <updated>2021-04-21T04:04:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 编码 ：</p>
<pre><code>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</code></pre>
<p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<p><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code><br>
<code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code><br>
注意，消息不能分组为  <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 <code>s</code> ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 <code>32</code> 位 的整数。</p>
<h4 id="样例1">样例1</h4>
<pre><code>输入：s = &quot;226&quot;
输出：3
解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。
</code></pre>
<h4 id="样例2">样例2</h4>
<pre><code>输入：s = &quot;0&quot;
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -&gt; &quot;10&quot; 和 'T'-&gt; &quot;20&quot; 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
</code></pre>
<h4 id="样例3">样例3</h4>
<pre><code>输入：s = &quot;06&quot;
输出：0
解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。
</code></pre>
<hr>
<h3 id="算法1">算法1</h3>
<h4 id="动态规划-on">(动态规划)  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4>
<ul>
<li>状态表示：<code>f[i]</code>表示<code>s</code>的前<code>i</code>个字符的解码方法总数</li>
<li>状态转移：如果<code>s[i]</code>不为0，单字符可解码，<code>f[i] += f[i-1]</code>；如果<code>s[i-1]</code>存在，且<code>s[i-1]</code>与<code>s[i]</code>组成的数字在<code>[10,26]</code>之间，则<code>f[i] += f[i-2]</code></li>
<li>初始化：由于<code>f[i-1]</code>和<code>f[i-2]</code>都可能被用到，所以<code>f[0]</code>应该被设置为<code>1</code>，表示空串的解码次数为<code>1</code></li>
<li>注意
<ol>
<li>前导<code>0</code>需要特判</li>
<li>状态定义为前<code>i</code>个字符时，可以在字符串前加个空格作为哨兵，否则下标需要减一</li>
</ol>
</li>
</ul>
<h4 id="java-代码">Java 代码</h4>
<pre><code class="language-java">class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        s = &quot; &quot; + s;
        // s中前i个字符的解码方法总数
        int[] f = new int[n+1];
        if(s.charAt(0) == '0') return 0;
        f[0] = 1;
        for(int i = 1; i &lt;= n; i++){
            if(s.charAt(i) != '0') f[i] += f[i-1];
            if(i &gt; 1){
                int num = (s.charAt(i-1) - '0') * 10 + s.charAt(i) - '0';
                if(num &gt;= 10 &amp;&amp; num &lt;= 26) f[i] += f[i-2];
            }
        }
        return f[n];
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[题解]LeetCode1707.与数组中元素的最大异或值]]></title>
        <id>https://Ryan-ovo.github.io/post/solution-leetcode1707/</id>
        <link href="https://Ryan-ovo.github.io/post/solution-leetcode1707/">
        </link>
        <updated>2021-04-19T02:48:24.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</a>
<ul>
<li><a href="#%E6%A0%B7%E4%BE%8B1">样例1</a></li>
<li><a href="#%E6%A0%B7%E4%BE%8B2">样例2</a></li>
<li><a href="#%E6%8F%90%E7%A4%BA">提示</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%951">算法1</a>
<ul>
<li><a href="#0-1%E5%AD%97%E5%85%B8%E6%A0%91-%E7%A6%BB%E7%BA%BF%E6%80%9D%E6%83%B3-onlogn">(0-1字典树 + 离线思想)  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></a></li>
<li><a href="#java-%E4%BB%A3%E7%A0%81">Java 代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="题目描述">题目描述</h3>
<p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [xi, mi]</code> 。</p>
<p>第 <code>i</code> 个查询的答案是 <code>xi</code> 和任何 <code>nums</code> 数组中不超过 <code>mi</code> 的元素按位异或<code>（XOR）</code>得到的最大值。换句话说，答案是 <code>max(nums[j] XOR xi)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= mi</code> 。如果 <code>nums</code> 中的所有元素都大于 <code>mi</code>，最终答案就是 <code>-1</code> 。</p>
<p>返回一个整数数组 <code>answer</code> 作为查询的答案，其中 <code>answer.length == queries.length</code> 且 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<h4 id="样例1">样例1</h4>
<pre><code>输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出：[3,3,7]
解释：
1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。
2) 1 XOR 2 = 3.
3) 5 XOR 2 = 7.
</code></pre>
<h4 id="样例2">样例2</h4>
<pre><code>输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]
输出：[15,-1,5]
</code></pre>
<h4 id="提示">提示</h4>
<ul>
<li>1 &lt;= nums.length, queries.length &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li>
<li>queries[i].length == 2</li>
<li>0 &lt;= nums[j], <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<hr>
<h3 id="算法1">算法1</h3>
<h4 id="0-1字典树-离线思想-onlogn">(0-1字典树 + 离线思想)  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></h4>
<ul>
<li>由于每个查询中限制了数组中可选的最大元素不能超过m，所以基于离线思想，给queries数组对于m进行排序并记录原来的下标，按m从小到大来记录答案</li>
<li>排序原数组，并遍历查询数组：如果元素小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则插入0-1字典树，并统计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与字典树中所有数的异或的最大值，最后在对应下标记录答案即可</li>
</ul>
<h4 id="java-代码">Java 代码</h4>
<pre><code class="language-java">class Solution {
    class Node{
        Node[] son = new Node[2];
    }
    Node root = new Node();
    void insert(int x){
        Node p = root;
        for(int i = 30; i &gt;= 0; i--){
            int t = (x &gt;&gt; i) &amp; 1;
            if(p.son[t] == null){
                p.son[t] = new Node();
            }
            p = p.son[t];
        }
    }

    int search(int x){
        Node p = root;
        int target = 0;
        for(int i = 30; i &gt;= 0; i--){
            int t = (x &gt;&gt; i) &amp; 1;
            if(p.son[t ^ 1] != null){
                p = p.son[t ^ 1];
                target |= 1 &lt;&lt; i;
            }else{
                p = p.son[t];
            }
        }
        return target;
    }

    public int[] maximizeXor(int[] nums, int[][] queries) {
        int n = nums.length, m = queries.length;
        Arrays.sort(nums);
        Map&lt;int[],Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0; i &lt; m; i++){
            map.put(queries[i], i);
        }
        Arrays.sort(queries, (o1, o2) -&gt; o1[1] - o2[1]);
        int[] res = new int[m];
        int k = 0;
        for(int i = 0; i &lt; m; i++){
            int a = queries[i][0], b = queries[i][1];
            while(k &lt; n &amp;&amp; nums[k] &lt;= b){
                insert(nums[k++]);
            }
            if(k == 0) res[map.get(queries[i])] = -1;
            else res[map.get(queries[i])] = search(a);
        }
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[题解]LeetCode421.数组中两个数的最大异或和]]></title>
        <id>https://Ryan-ovo.github.io/post/ti-jie-leetcode421shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-he/</id>
        <link href="https://Ryan-ovo.github.io/post/ti-jie-leetcode421shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-he/">
        </link>
        <updated>2021-04-18T14:26:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。</p>
<p>找到 ai 和aj 最大的异或 (XOR) 运算结果，其中0 ≤ i,  j &lt; n 。</p>
<p>你能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间解决这个问题吗？</p>
<h4 id="样例">样例</h4>
<pre><code>输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.
</code></pre>
<hr>
<h3 id="算法1">算法1</h3>
<h4 id="0-1字典树-on">(0-1字典树)  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></h4>
<p>思想：将每个数字的二进制位，从高位到低位存储到前缀树中，也就是说前缀树中仅有0和1这两个数字。</p>
<ul>
<li>根据数学知识可以知道：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span> &gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>+...+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></li>
<li>可以发现：异或只要两位不相同就是1，如果高位有一位是1，那么数就会大于这一位是0且低位全是1的情况。这就是从高位开始遍历的贪心思想。</li>
<li>如果某一位二进制位是0，但是前缀树的遍历过程中没有1的分支，则被迫走0的分支，反过来同理</li>
<li>树的高度由二进制位最多的数字决定，所以分支非0即1，不会有某一个数的二进制位先走到底的情况</li>
</ul>
<h4 id="java-代码">Java 代码</h4>
<pre><code class="language-java">class Solution {
    class Node{
        Node[] son = new Node[2];
    }
    Node root = new Node();
    void insert(int x){
        Node p = root;
        for(int i = 30; i &gt;= 0; i--){
            int t = (x &gt;&gt; i) &amp; 1;
            if(p.son[t] == null){
                p.son[t] = new Node();
            }
            p = p.son[t];
        }
    }

    int search(int x){
        Node p = root;
        int xor = 0;
        for(int i = 30; i &gt;= 0; i--){
            int t = (x &gt;&gt; i) &amp; 1;
            if(p.son[t ^ 1] != null){
                xor += (1 &lt;&lt; i);
                p = p.son[t ^ 1];
            }else{
                p = p.son[t];
            }
        }
        return xor;
    }

    public int findMaximumXOR(int[] nums) {
        if(nums.length == 0) return 0;
        for(int x: nums) insert(x);
        int res = 0;
        for(int x: nums) res = Math.max(res, search(x));
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode第237场周赛题解]]></title>
        <id>https://Ryan-ovo.github.io/post/leetcode-di-237-chang-zhou-sai-ti-jie/</id>
        <link href="https://Ryan-ovo.github.io/post/leetcode-di-237-chang-zhou-sai-ti-jie/">
        </link>
        <updated>2021-04-18T09:33:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="t1-判断句子是否为全字母句">T1-<a href="https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/">判断句子是否为全字母句</a></h3>
<ul>
<li>思路：模拟+计数</li>
</ul>
<pre><code class="language-java">class Solution {
    public boolean checkIfPangram(String s) {
        boolean[] st = new boolean[26];
        for(char c: s.toCharArray()){
            st[c-'a'] = true;
        }
        for(int i = 0; i &lt; 26; i++){
            if(!st[i]) return false;
        }
        return true;
    }
}
</code></pre>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="t2-雪糕的最大数量">T2-<a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">雪糕的最大数量</a></h3>
<ul>
<li>思路：贪心</li>
<li>将数组从小到大排序依次选取即可</li>
</ul>
<pre><code class="language-java">class Solution {
    public int maxIceCream(int[] costs, int coins) {
        Arrays.sort(costs);
        int res = 0;
        int n = costs.length;
        for(int i = 0; i &lt; n; i++){
            if(coins - costs[i] &gt;= 0) {
                coins -= costs[i];
                res++;
            }
            if(coins &lt;= 0) return res;
        }
        return res;
    }
}
</code></pre>
<h3 id="t3-单线程cpu">T3-<a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程CPU</a></h3>
<ul>
<li>思路：贪心+堆</li>
<li>创建三元组数组，分别保存开始时间，持续时间和下标；创建一个小根堆，先按照持续时间排序，相同再按照下标排序</li>
<li>对任务进行开始时间从小到大的排序，然后按题意进行模拟。
<ol>
<li>每次先求出当前进行到的时间，然后将所有开始时间早于当前时间的任务加入优先队列（如果当前时间堆中没有任务，则快进到下一个任务的开始时间）</li>
<li>取出堆顶的任务进行处理，并更新当前时间，直到任务列表全部执行结束</li>
</ol>
</li>
</ul>
<pre><code class="language-java">class Solution {
    class Task{
        int st;
        int duration;
        int idx;
    }
    public int[] getOrder(int[][] tasks) {
        int n = tasks.length;
        int[] res = new int[n];
        Task[] ts = new Task[n];
        for(int i = 0; i &lt; n; i++){
            ts[i] = new Task();
            ts[i].st = tasks[i][0];
            ts[i].duration = tasks[i][1];
            ts[i].idx = i;
        }
        PriorityQueue&lt;Task&gt; heap = new PriorityQueue&lt;&gt;((t1, t2) -&gt; t1.duration == t2.duration ? t1.idx - t2.idx : t1.duration - t2.duration);
        Arrays.sort(ts, (t1, t2) -&gt; t1.st - t2.st);
        int i = 0, u = 0;
        int now = 0; // 当前进行到多少分钟
        while(heap.size() != 0 || i &lt; n){
            if(heap.size() == 0){
                now = Math.max(now, ts[i].st);
            }
            while(i &lt; n &amp;&amp; ts[i].st &lt;= now){
                heap.offer(ts[i++]);
            }
            Task t = heap.poll();
            now += t.duration;
            res[u++] = t.idx;
        }
        return res;
    }
}
</code></pre>
<h3 id="t4-所有数对按位与结果的异或和">T4-<a href="https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/">所有数对按位与结果的异或和</a></h3>
<h4 id="方法1分配律">方法1：分配律</h4>
<ul>
<li><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 3: a &amp;̲ (b ^ c) = (a &amp;…'>a &amp; (b ^ c) = (a &amp; b) ^ (a &amp; c)</span></li>
</ul>
<pre><code class="language-java">class Solution {
    public int getXORSum(int[] a, int[] b) {
        int s1 = 0, s2 = 0;
        for(int x: a) s1 ^= x;
        for(int x: b) s2 ^= x;
        return s1 &amp; s2;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[题解]LeetCode730.统计不同回文子序列]]></title>
        <id>https://Ryan-ovo.github.io/post/ti-jie-leetcode730tong-ji-bu-tong-hui-wen-zi-xu-lie/</id>
        <link href="https://Ryan-ovo.github.io/post/ti-jie-leetcode730tong-ji-bu-tong-hui-wen-zi-xu-lie/">
        </link>
        <updated>2021-04-17T14:38:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<p>给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。</p>
<p>通过从 S 中删除 0 个或多个字符来获得子序列。</p>
<p>如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。</p>
<p>如果对于某个  i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。</p>
<h4 id="样例">样例</h4>
<pre><code>输入：
S = 'bccb'
输出：6
解释：
6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。
</code></pre>
<h4 id="提示">提示</h4>
<ul>
<li>字符串 S 的长度将在[1, 1000]范围内。</li>
<li>每个字符 S[i] 将会是集合 {'a', 'b', 'c', 'd'} 中的某一个。</li>
</ul>
<hr>
<h3 id="算法1">算法1</h3>
<h4 id="区间dp-双端队列-on2">(区间DP + 双端队列)  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></h4>
<ul>
<li>状态表示：<code>f[i][j]</code>表示<code>s[i]</code>到<code>s[j]</code>中包含的不同回文子序列个数，包含空串，答案为<code>f[0][n-1] - 1</code></li>
<li>状态转移：对于某个区间<code>[i, j]</code>，找到区间内最左边的和最右边的相同字符，下标为<code>l</code>和<code>r</code>，<code>f[i][j] += f[l + 1][r - 1]</code></li>
<li>由于区间DP枚举左右端点的性质，可以用一个双端队列维护这个过程：右端点更新时入队，左端点更新时出队。</li>
<li>对于每个不同字母都开一个deque，如果区间内包含某个字母，则区间内不同子序列个数加一，再判断是否有两个及以上不同的字符，进行状态转移；如果区间内不包含某个字符，则判断下一个字符</li>
</ul>
<h4 id="java-代码">Java 代码</h4>
<pre><code class="language-java">class Solution {
    public int countPalindromicSubsequences(String s) {
        int n = s.length();
        int mod = (int)1e9 + 7;
        // f[i][j]表示s[i~j]中回文子序列个数，包含空串
        int[][] f = new int[n][n];
        for(int[] ff: f) Arrays.fill(ff, 1);
        // 单字符，包含空串
        for(int i = 0; i &lt; n; i++) f[i][i] = 2;
        for(int len = 2; len &lt;= n; len++){
            Deque&lt;Integer&gt;[] dq = new Deque[4];
            for(int i = 0; i &lt; 4; i++){
                dq[i] = new LinkedList&lt;&gt;();
            }
            for(int i = 0; i &lt; len - 1; i++){
                dq[s.charAt(i) - 'a'].offerLast(i);
            }
            for(int i = 0; i + len - 1 &lt; n; i++){
                int j = i + len - 1;
                dq[s.charAt(j) - 'a'].offerLast(j);
                for(int k = 0; k &lt; 4; k++){
                    if(dq[k].size() &gt; 0){
                        f[i][j]++;
                        int l = dq[k].peekFirst();
                        int r = dq[k].peekLast();
                        if(l &lt; r){
                            f[i][j] = (f[i][j] + f[l + 1][r - 1]) % mod;
                        }
                    }
                }
                dq[s.charAt(i) - 'a'].pollFirst();
            }
        }
        return f[0][n-1] - 1;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++语法整理]]></title>
        <id>https://Ryan-ovo.github.io/post/cpp_grammer/</id>
        <link href="https://Ryan-ovo.github.io/post/cpp_grammer/">
        </link>
        <updated>2021-04-13T10:50:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="第一章变量-输入输出-表达式和顺序语句">第一章.变量、输入输出、表达式和顺序语句</h3>
<h4 id="11-变量">1.1 变量</h4>
<ul>
<li>
<p>bool false/true 1byte</p>
</li>
<li>
<p>char 'c', 'a', ' ', ' \n' 1byte</p>
</li>
<li>
<p>int -2147483648 ~ 2147483647 (-2^31 ~ 2^31-1) 4byte</p>
</li>
<li>
<p>float 1.23, 2.5, 1.235e2, 6-7位有效数字 4byte</p>
</li>
<li>
<p>double 15-16位有效数字 8bype</p>
</li>
<li>
<p>long long (-2^63 ~ 2^63-1) btype</p>
</li>
<li>
<p>long double 16bype</p>
</li>
<li>
<p>字节1B = 8bit</p>
</li>
<li>
<p>带宽8Mb = 下载速度1MB/s</p>
</li>
</ul>
<pre><code class="language-c++">int a, b = 2, c = b;
float d = 1.5, e = 1, f = 1.235e2;
bool g = true, h = false;
char j = 'a', k = 'b';
long long l = 10000000000000000000ll;// 大小写l/L均可，不写默认为整型，超过2^31-1可能变为负数
long double m = 123.45
</code></pre>
<h4 id="12输入输出">1.2输入输出</h4>
<ul>
<li>scanf, printf在头文件cstdio中</li>
</ul>
<pre><code class="language-c++">#include &lt;cstdio&gt;

using namespace std;

int main(){
    float a, b;
    // int对应%d, 不会读入空格
    // char对应%c, 会读入空格
    // float对应%f, 默认保留6位小数
    // double对应%lf, 默认保留6位小数
    // long long对应%lld
    // bool被当作整数来处理
    scanf(&quot;%f%f&quot;, &amp;a, &amp;b);
    printf(&quot;a + b = %.2f\na * b = %.3f\n&quot;, a+b, a*b);
    printf(&quot;%5d\n&quot;, 123);
    printf(&quot;%-5d\n&quot;, 123);
    printf(&quot;%05d\n&quot;, 123);
    printf(&quot;%5.2lf&quot;, 1.2);
}
</code></pre>
<ul>
<li>cin, cout, endl在头文件iostream中</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int main(){
    int a, b;
    // cin会自动过滤空格，输入中可以含有大量空格
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a+b &lt;&lt; endl;
}
</code></pre>
<h4 id="13-表达式">1.3 表达式</h4>
<ul>
<li>取模运算的结果正负取决于第一个数的正负</li>
</ul>
<pre><code class="language-c++">cout &lt;&lt; 5 % 2 &lt;&lt; endl;
cout &lt;&lt; -5 % 2 &lt;&lt; endl;
cout &lt;&lt; -5 % -2 &lt;&lt; endl;
</code></pre>
<ul>
<li>变量类型转换</li>
</ul>
<pre><code>int 可以和 float, double相互转换, 其中float, double转为int为下取整
int 可以和char相互转换，通过ASCII码表

运算会让低精度向高精度转换
int和float, double做运算 结果会转换为float, double类型
char和int做运算，结果会转换为int //A + 2 = 67, (char)(A + 2) = C
int和long long做运算，结果会转换为long long
float和double做运算，结果会转换为double
</code></pre>
<h3 id="第二章判断结构">第二章.判断结构</h3>
<ul>
<li>判断闰年</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int year;
    cin &gt;&gt; year;
    if(year % 100 == 0){
        if(year % 400 == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }else{
        if(year % 4 == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<ul>
<li>逻辑运算符简化</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int year;
    cin &gt;&gt; year;
    // &amp;&amp;的优先级比||高, 不用加括号
    if(year % 400 == 0 || year % 100 != 0 &amp;&amp; year % 4 == 0){
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    }else{
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="第三章循环结构">第三章.循环结构</h3>
<ul>
<li>循环结构语法和Java一模一样</li>
</ul>
<pre><code class="language-c++">// while循环
while(){

}

// do-while循环
do{

}while();

// for循环
for(int i = 0; i &lt; n; i++){

}

// 控制语句
break;
continue;
</code></pre>
<ul>
<li>奇数矩阵打印菱形</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int n;
    cin &gt;&gt; n;
    int cx = n/2, cy = n/2;
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; n; j++){
            if(abs(i-cx) + abs(j-cy) &lt;= n/2){
                cout &lt;&lt; &quot;*&quot;;
            }else{
                cout &lt;&lt; &quot; &quot;;
            }
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="第四章数组">第四章.数组</h3>
<h4 id="41-一维数组">4.1 一维数组</h4>
<ul>
<li>定义在函数内部的数组存储在栈空间中（局部变量），如果没有初始化则每个值都为随机数</li>
<li>定义在函数外部的数组存储在堆空间中（全局变量），默认值都为0</li>
<li>栈空间通常有大小限制，所以数组长度太大的数组局部变量，循环访问时可能发生段错误（解决方法：放到堆空间中）</li>
</ul>
<pre><code class="language-c++">// 定义了一个长度为3的数组
int a[3] = {0, 1, 2};
// 定义了一个长度为3的数组，长度由编译器计算
int b[] = {0, 1, 2};
// 定义了一个长度为5的数组，没有给出的值默认为0，等价于{0, 1, 2, 0, 0}
int c[5] = {0, 1, 2};
// 定义了一个长度为3的字符数组
char d[] = {'a', 'b', 'c'};
// 将数组全部初始化为0的写法
int f[100] = {0};
</code></pre>
<ul>
<li>将长度为n的数组顺时针旋转k次</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt; //reverse函数在algorithm库中
using namespace std;

int a[100];

int main(){
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
    // reverse(数组的起始位置, 数组的终止位置的下一个位置)
    reverse(a, a + n);
    reverse(a, a + k);
    reverse(a + k, a + n);
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    return 0;
}
</code></pre>
<ul>
<li>memset函数</li>
</ul>
<pre><code class="language-c++">// 为数组进行初始化，按字节赋值
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main(){
    int a[10], b[10], c[10];
    // int变量占4字节, 长度为10的int数组占40字节
    // memset按字节赋值, 一个字节有8个bit位, 把8bit位全部置为第二个参数
    // memset(a, 5, sizeof a)表示把每8bit都置为00000101
    memset(a, 0, 40);
    // sizeof为运算符, 可以计算出数组一共占多少字节
    memset(a, 0, sizeof a);
    // 只有0和-1初始化完恰好数组为全0或者全-1
    memset(b, -1, sizeof b);
    // 0x3f3f3f3f是一个非常大的数，其两倍都不会超出int的范围，常用于初始化一个很大的值
    memset(c, 0x3f, sizeof c);
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; c[i] &lt;&lt; ' ';
    return 0;
}

</code></pre>
<ul>
<li>memcpy函数在</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main(){
    int a[10], b[10];
    for(int i = 0; i &lt; 10; i++) a[i] = i;
    memcpy(b, a, sizeof a);
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    return 0;
}
</code></pre>
<h4 id="42-二维数组">4.2 二维数组</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int main(){
    // 每一维都是一维数组，都可以按一维数组来初始化
    // {{1, 2, 3, 4}, {1, 0, 0, 0}, {1, 0, 0, 0}} 不足补零
    int a[3][4] = {{1, 2, 3, 4}, {1}, {1}};  
    for(int i = 0; i &lt; 3; i++){
        for(int j = 0; j &lt; 4; j++){
            cout &lt;&lt; a[i][j] &lt;&lt; ' ';
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<ul>
<li>多维数组可以实现，只要不超内存限制即可</li>
<li>二十维的数组，每一维的长度为2，能存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>个数</li>
</ul>
<h3 id="第七章类-结构体-指针-引用">第七章.类 结构体 指针 引用</h3>
<h4 id="类">类</h4>
<ul>
<li>类可以把变量，数组，函数等打包到一起使用</li>
<li>类中不写修饰符默认为private</li>
<li>构造函数写法1：</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person{
    private:
        int age, height;
        double money;
    public:
        Person(){}
        Person(int _age, int _height, double _money){
            age = _age;
            height = _height;
            money = _money;
        }
        string name;
        void say(){
            cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
        }
        int get_age(){
            return age;
        }
        void add_money(int x){
            money += x;
        }
};

int main(){
    Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    p.age = 18; // 无法访问私有变量
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>构造函数写法2：</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person{
    private:
        int age, height;
        double money;
    public:
        Person(){}
        Person(int _age, int _height, double _money): age(_age), height(_height), money(_money){}
        string name;
        void say(){
            cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
        }
        int get_age(){
            return age;
        }
        void add_money(int x){
            money += x;
        }
};

int main(){
    Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    // p.age = 18; // 无法访问私有变量
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="结构体">结构体</h4>
<ul>
<li>结构体和类的作用相同，但是结构体用来存储相对简单的数据捆绑类型，类用来存储相对复杂，逻辑混乱的各类数据</li>
<li>结构体中修饰符不写默认为public</li>
<li>写法和类几乎一样</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

struct Person{
    int age, height;
    double money;
    string name;

    Person(){}
    Person(int _age, int _height, double _money): age(_age), height(_height), money(_money){}
    
    void say(){
        cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
    }
    int get_age(){
        return age;
    }
    void add_money(int x){
        money += x;
    }
};

int main(){
    Person p = {18, 180, 0};
    // Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    p.age = 18;
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="第八章stl">第八章.STL</h3>
<h4 id="pair">pair</h4>
<ul>
<li>二元组，泛型确定数据类型</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(){
    pair&lt;int,string&gt; a;
    // 初始化
    a = {1, &quot;aaa&quot;};
    a = make_pair(2, &quot;bbb&quot;);
    cout &lt;&lt; a.first &lt;&lt; ' ' &lt;&lt; a.second &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="vector">vector</h4>
<ul>
<li>定义与初始化</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    // 初始化为给定的值
    vector&lt;int&gt; a({1, 2, 3});
    // 初始化二维vector, 并赋初值为1
    vector&lt;vector&lt;int&gt;&gt; b(3, vector&lt;int&gt;(4, 1));
    // 定义长度为5的vector, 默认值都为0
    vector&lt;int&gt; c(5);
    // 定义长度为5的vector, 并赋初值为1
    vector&lt;int&gt; d(5, 1);
    return 0;
}
</code></pre>
<ul>
<li>遍历</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; a({1, 2, 3});
    // 类似数组
    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    //迭代器(一般不用)
    for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(auto i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(auto i = a.begin(); i &lt; a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    // for-each
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    return 0;
}
</code></pre>
<ul>
<li>常用函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; a({1, 2, 3});
    // 遍历
    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    for(auto i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    
    // 数组长度
    cout &lt;&lt; a.size() &lt;&lt; endl;
    // 判空
    cout &lt;&lt; a.empty() &lt;&lt; endl;
    // 清空vector
    a.clear();
    // front(): 取出第一个元素
    // back(): 取出最后一个元素
    // rbegin(): 反向迭代器，指向最后一个元素
    // rend(): 反向迭代器，指向第一个元素的前一个元素
    // [begin(), end()) 前闭后开
    cout &lt;&lt; a.front() &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; *a.begin() &lt;&lt; ' ' &lt;&lt; *(a.rend()-1) &lt;&lt; endl;
    cout &lt;&lt; a.back() &lt;&lt; ' ' &lt;&lt; a[a.size()-1] &lt;&lt; ' ' &lt;&lt; *(a.end()-1) &lt;&lt; ' ' &lt;&lt; *a.rbegin() &lt;&lt; endl;
    // 往最后插入元素
    a.push_back(4);
    // 删除最后一个元素
    a.pop_back();
    
    // resize(n): 调整容器的大小, 使其包含n个元素
    // 如果n比原来长度小, 则保留前n个元素, 如果n比原来长度大, 则用0补齐
    // resize(n, v): 调整容器大小为n, 补齐的部分初始化为-1
    a.resize(10);
    // 1 2 3 0 0 0 0 0 0 0 
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    a.resize(2);
    // 1 2 
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    a.resize(5, -1);
    // 1 2 -1 -1 -1
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="queue">queue</h4>
<ul>
<li>头文件queue中含有queue, priority_queue</li>
<li>队列和栈都没有clear函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    // 大根堆
    priority_queue&lt;int&gt; a;
    // 小根堆
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;
    // 二元组大根堆
    priority_queue&lt;pair&lt;int, int&gt;&gt; c;
    
    // queue没有clear()函数，清空重新定义一遍即可、
    q = queue&lt;int&gt;();

    struct Rec{
        int a, b;
        bool operator&gt; (const Rec&amp; t) const{
            return a &gt; t.a;
        }
    };
    // 堆中存放结构体: 大根堆重载小于号, 小根堆重载大于号
    priority_queue&lt;Rec, vector&lt;Rec&gt;, greater&lt;Rec&gt;&gt; d;
    d.push({1, 2});
    d.push({-1, 1});
    // -1
    cout &lt;&lt; d.top().a &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>常用方法</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    q.push(1); // 队尾插入元素
    q.pop(); // 队头删除元素
    cout &lt;&lt; q.size() &lt;&lt; endl; // 队列大小
    cout &lt;&lt; q.front() &lt;&lt; endl; // 队头元素
    cout &lt;&lt; q.back() &lt;&lt; endl; // 队尾元素
    // 大根堆
    priority_queue&lt;int&gt; a;
    a.push(1); // 堆中插入元素
    a.pop(); // 删除堆顶元素
    cout &lt;&lt; a.top() &lt;&lt; endl; // 获取堆顶元素
    return 0;
}
</code></pre>
<h4 id="stack">stack</h4>
<ul>
<li>栈：先进后出</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

int main(){
    stack&lt;int&gt; stk;
    stk.push(1); // 压栈
    stk.pop(); // 弹出栈顶元素
    stk.top(); // 获取栈顶元素
}
</code></pre>
<h3 id="deque">deque</h3>
<ul>
<li>头文件：deque</li>
<li>双端队列：加强版的vector</li>
</ul>
<pre><code class="language-c++">#include &lt;deque&gt;
using namespace std;
int main(){
    deque&lt;int&gt; a;
    // 迭代器
    a.begin(), a.end();
    a.front(), a.back();
    // 常用函数
    a.push_back(1), a.push_front(2);
    a[0];
    a.pop_back(), a.pop_front();
    return 0;
}
</code></pre>
<h3 id="set">set</h3>
<ul>
<li>头文件：set, unordered_set</li>
<li>set：有序集合（元素不能重复）</li>
<li>multiset：有序多重集合（元素可以重复）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
using namespace std;
int main(){
    set&lt;int&gt; a;
    multiset&lt;int&gt; b;

    set&lt;int&gt;::iterator it = a.begin();
    it++; it--;
    ++it; --it;
    a.end();

    a.insert(x);
    if(a.find(x) == a.end()) //判断x在a中是否存在

    a.erase(x); // 删除所有值为x的迭代器
    a.erase(it); // 删除it这个迭代器

    a.lower_bound(x); // 找到大于等于x的最小元素的迭代器, 并返回迭代器
    a.upper_bound(x); // 找到大于x的最小元素的迭代器, 并返回迭代器

    a.count(x); // x在a中出现了几次, set只有0和1两个值
    return 0;
}   
</code></pre>
<h4 id="map">map</h4>
<ul>
<li>头文件：map, unordered_map</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
using namespace std;
int main(){
    map&lt;int, int&gt; a;
    a[1] = 2;
    a[2] = 3;
    a.insert({3, 4});
    a.erase(3);
    for (auto&amp; [k, v]: a){
        cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl;
    }
    
    for(auto&amp; item: a){
        cout &lt;&lt; item.first &lt;&lt; ' ' &lt;&lt; item.second &lt;&lt; endl;
    }
    
    for(map&lt;int, int&gt;::iterator it = a.begin(); it != a.end(); it++){
        cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
}
</code></pre>
<h4 id="bitset">bitset</h4>
<ul>
<li>头文件：bitset</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;bitset&gt;
using namespace std;
int main(){
    // 实际上存储的是二进制串，可以用于位运算
    // &lt;&gt;内表示的是二进制串的长度
    bitset&lt;1000&gt; a, b;
    a[0] = 1; // 第0位设为1
    b[1] = 1; // 第1位设为1
    a &amp;= b; 
    a |= b;
    cout &lt;&lt; a &lt;&lt; endl; //打印位运算后的结果
    a.set(3); // 第3位设为1
    a.reset(3); // 第3位设为0 
    cout &lt;&lt; a[3] &lt;&lt; endl; // 查看第3位是0还是1
    return 0;
}
</code></pre>
<h3 id="常用函数">常用函数</h3>
<h4 id="unique">unique</h4>
<ul>
<li>unique()：去重数组或者容器，返回去重后数组的最后一个位置下一个位置的指针或迭代器</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int a[7] = {1, 1, 2, 3, 3, 4, 4};
    vector&lt;int&gt; b({1, 1, 2, 3, 3, 4, 4});
    vector&lt;int&gt; c({1, 1, 2, 3, 3, 4, 4});
    // 返回去重后的数组长度
    int n = unique(a, a + 7) - a;
    cout &lt;&lt; n &lt;&lt; endl;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    int m = unique(b.begin(), b.end()) - b.begin();
    for(int i = 0; i &lt; m; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // erase()：移除从两个迭代器中间的所有元素
    c.erase(unique(c.begin(), c.end()), c.end());
    for(int x: c) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<h4 id="random_shuffle">random_shuffle</h4>
<ul>
<li>random_shuffle()：随机打乱数组</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
using namespace std;
int main(){
    vector&lt;int&gt; a({1, 2, 3, 4, 5});
    srand(time(0));
    random_shuffle(a.begin(), a.end());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    return 0;
}
</code></pre>
<h4 id="sort">sort</h4>
<ul>
<li>给数组/可变数组排序</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

bool cmp(int a, int b){
    // a是否排在b前面
    return a &gt; b;
}

int main(){
    vector&lt;int&gt; a({2, 4, 1, 5, 3});
    // 默认从小到大排序
    sort(a.begin(), a.end());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // 从大到小排序, 写法一：传参
    sort(a.begin(), a.end(), greater&lt;int&gt;());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // 从大到小排序, 写法二：传入比较函数
    sort(a.begin(), a.end(), cmp);
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>给结构体数组排序：定义比较函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

struct Rec{
    int x, y;
}q[5];

bool cmp(Rec a, Rec b){
    // a是否排在b前面
    return a.x + a.y &gt; b.x + b.y;
}

int main(){
    for(int i = 0; i &lt; 5; i++){
        q[i].x = i;
        q[i].y = i &lt;&lt; 1;
    }
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    
    sort(q, q + 5, cmp);
    
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>给结构体数组排序：重载小于号</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

struct Rec{
    int x, y;
    bool operator&lt;(const Rec&amp; t) const{
        return x + y &gt; t.x + t.y;
    }
}q[5];


int main(){
    for(int i = 0; i &lt; 5; i++){
        q[i].x = i;
        q[i].y = i &lt;&lt; 1;
    }
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    
    sort(q, q + 5);
    
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode题型总结]]></title>
        <id>https://Ryan-ovo.github.io/post/leetcode-ti-xing-zong-jie/</id>
        <link href="https://Ryan-ovo.github.io/post/leetcode-ti-xing-zong-jie/">
        </link>
        <updated>2021-04-13T06:06:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目录">目录</h3>
<ul>
<li>1.二分
<ul>
<li>1.1 索引二分</li>
<li>1.2 值域二分</li>
</ul>
</li>
<li>2.链表</li>
<li>3.数组</li>
<li>4.树</li>
<li>5.Trie树（字典树）</li>
<li>6.堆</li>
<li>7.栈、队列
<ul>
<li>7.1 转换</li>
<li>7.2 单调栈</li>
<li>7.3 单调队列</li>
<li>7.4 逆波兰表达式/计算器</li>
<li>7.5 括号序列</li>
</ul>
</li>
<li>8.双指针
<ul>
<li>8.1 同向双指针</li>
<li>8.2 滑动窗口</li>
<li>8.3 逆向双指针</li>
</ul>
</li>
<li>9.哈希表</li>
<li>10.位运算</li>
<li>11.排序</li>
<li>12.数学</li>
<li>13.搜索
<ul>
<li>13.1 DFS（深度优先搜索）</li>
<li>13.2 BFS（宽度优先搜索）</li>
</ul>
</li>
<li>14.贪心
<ul>
<li>14.1 区间贪心</li>
</ul>
</li>
<li>15.分治</li>
<li>16.动态规划
<ul>
<li>16.1 背包问题
<ul>
<li>16.1.1 01背包</li>
<li>16.1.2 完全背包</li>
<li>16.1.3 二维费用背包</li>
</ul>
</li>
<li>16.2 LIS模型</li>
<li>16.3 线性DP
<ul>
<li>抢劫问题，双路径问题，股票问题，表达式匹配</li>
</ul>
</li>
<li>16.4 区间DP</li>
<li>16.5 树形DP</li>
<li>16.6 记忆化搜索</li>
<li>16.7 状态机DP</li>
<li>16.8 状压DP</li>
</ul>
</li>
<li>17.图论</li>
<li>18.树状数组</li>
<li>19.蓄水池抽样</li>
<li>20.字符串</li>
</ul>
<hr>
<h3 id="1二分">1.二分</h3>
<h4 id="11-索引二分">1.1 索引二分</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">LeetCode33.搜索旋转排序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode34.在排序数组中查找元素的第一个和最后一个位置</a></li>
<li><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode35.搜索插入位置</a></li>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">LeetCode81.搜索旋转排序数组Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">LeetCode74.搜索二维矩阵</a>（坐标变换：二维到一维）</li>
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array">LeetCode153.寻找旋转排序数组中的最小值</a></li>
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii">LeetCode154.寻找旋转排序数组中的最小值Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/find-peak-element/">LeetCode162.寻找峰值</a></li>
<li><a href="https://leetcode-cn.com/problems/h-index/">LeetCode274.H指数</a>（排序）</li>
<li><a href="https://leetcode-cn.com/problems/h-index-ii/">LeetCode275.H指数Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode278.第一个错误的版本</a></li>
<li><a href="https://leetcode-cn.com/problems/find-right-interval/">LeetCode436.寻找右区间</a></li>
<li><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">LeetCode540.有序数组中的单一元素</a>（trick：x^1的奇偶性）</li>
<li><a href="https://leetcode-cn.com/problems/binary-search/">LeetCode704.二分查找</a>（二分模板题）</li>
</ul>
<h4 id="12-值域二分">1.2 值域二分</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">LeetCode374.猜数字大小</a></li>
<li><a href="https://leetcode-cn.com/problems/sqrtx/">LeetCode69.x的平方根</a></li>
<li><a href="https://leetcode-cn.com/problems/valid-perfect-square/">LeetCode367.有效的完全平方数</a></li>
<li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number">LeetCode287.寻找重复数</a>（鸽巢原理+二分）</li>
<li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">LeetCode378.有序矩阵中第K小的元素</a></li>
<li><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">LeetCode410.分割数组的最大值</a></li>
<li><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">LeetCode875.爱吃香蕉的珂珂</a></li>
<li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">LeetCode1011.在D天内送达包裹的能力</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">LeetCode1482.制作m束花所需的最少天数</a></li>
<li><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">LeetCode1552.两球之间的磁力</a></li>
<li><a href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/">LCP12.小张刷题计划</a></li>
</ul>
<h3 id="2链表">2.链表</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers">LeetCode2.两数相加</a>（高精度加法）</li>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">LeetCode445.两数相加Ⅱ</a>（高精度加法+栈）</li>
<li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">LeetCode19.删除链表的倒数第N个节点</a></li>
<li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">LeetCode21.合并两个有序链表</a></li>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">LeetCode23.合并K个升序链表</a>（多路归并）</li>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">LeetCode24.两两交换链表中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LeetCode25.K个一组翻转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/rotate-list/">LeetCode61.旋转链表</a>（快慢指针）</li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">LeetCode83.删除排序链表中的重复元素</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">LeetCode82.删除排序链表中的重复元素Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/partition-list">LeetCode86.分隔链表</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list">LeetCode206.翻转链表</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">LeetCode92.反转链表Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle">LeetCode141.环形链表</a></li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">LeetCode142.环形链表Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/reorder-list/">LeetCode143.重排链表</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">LeetCode160.相交链表</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">LeetCode203.移除链表元素</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">LeetCode234.回文链表</a></li>
<li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">LeetCode237.删除链表中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">LeetCode328.奇偶链表</a></li>
<li><a href="https://leetcode-cn.com/problems/design-linked-list/">LeetCode707.设计链表</a>（设计单链表，双链表模板题）</li>
<li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">LeetCode876.链表的中间节点</a></li>
</ul>
<h3 id="3数组">3.数组</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/valid-sudoku/">LeetCode36.有效的数独</a></li>
<li><a href="https://leetcode-cn.com/problems/rotate-image/">LeetCode48.旋转图像</a>（二维数组原地旋转）</li>
<li><a href="https://leetcode-cn.com/problems/merge-intervals/">LeetCode56.合并区间</a>（区间问题）</li>
<li><a href="https://leetcode-cn.com/problems/insert-interval/">LeetCode57.插入区间</a>（区间问题）</li>
<li><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">LeetCode73.矩阵置零</a></li>
<li><a href="https://leetcode-cn.com/problems/majority-element/">LeetCode169.多数元素</a>（摩尔投票法）</li>
<li><a href="https://leetcode-cn.com/problems/rotate-array/">LeetCode189.旋转数组</a></li>
<li><a href="https://leetcode-cn.com/problems/majority-element-ii/">LeetCode229.求众数2</a>（摩尔投票法）</li>
<li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">LeetCode238.除自身以外数组的乘积</a>（前后缀分解）</li>
<li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">LeetCode303.区域和检索-数组不可变</a>（一维前缀和）</li>
<li><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LeetCode304.二维区域和检索-矩阵不可变</a>（二维前缀和）</li>
<li><a href="https://leetcode-cn.com/problems/shuffle-an-array/">LeetCode384.打乱数组</a>（洗牌算法）</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode413.等差数列划分</a></li>
<li><a href="https://leetcode-cn.com/problems/battleships-in-a-board/">LeetCode419.甲板上的战舰</a></li>
<li><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LeetCode442.数组中重复的数据</a>（内卷法）</li>
<li><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">LeetCode448.找到所有数组中消失的数字</a>（内卷法）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">LeetCode453.最小移动次数使数组元素相等</a>（逆向思维）</li>
<li><a href="https://leetcode-cn.com/problems/array-partition-i/">LeetCode561.数组拆分Ⅰ</a></li>
<li><a href="https://leetcode-cn.com/problems/array-nesting/">LeetCode565.数组嵌套</a>（数组模拟图）</li>
<li><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">LeetCode566.重塑矩阵</a>（坐标变换）</li>
<li><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/">LeetCode1491.去掉最低工资和最高工资后的平均值</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/three-consecutive-odds/">LeetCode1550.存在连续三个奇数的数组</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">LeetCode1675.使数组互补的最少操作次数</a>（一维差分）</li>
</ul>
<h3 id="4树">4.树</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">LeetCode98.验证二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">LeetCode99.恢复二叉搜索树</a>（Morris遍历）</li>
<li><a href="https://leetcode-cn.com/problems/same-tree/">LeetCode100.相同的树</a></li>
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/">LeetCode101.对称二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LeetCode102.二叉树的层序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">LeetCode107.二叉树的层次遍历Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode103.二叉树的锯齿形层次遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LeetCode104.二叉树的最大深度</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">LeetCode105.从前序和中序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">LeetCode106.从中序和后序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">LeetCode108.将有序数组转换为二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">LeetCode109.有序链表转换二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">LeetCode110.平衡二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">LeetCode111.二叉树的最小深度</a></li>
<li><a href="https://leetcode-cn.com/problems/path-sum/">LeetCode112.路径总和</a></li>
<li><a href="https://leetcode-cn.com/problems/path-sum-ii/">LeetCode113.路径总和Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">LeetCode114.二叉树展开为链表</a></li>
<li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">LeetCode116.填充每个节点的下一个右侧节点指针</a></li>
<li><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">LeetCode117.填充每个节点的下一个右侧节点指针Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">LeetCode124.二叉树中的最大路径和</a></li>
<li><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">LeetCode129.求根到叶子节点数字之和</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">LeetCode144.二叉树的前序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode145.二叉树的后序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">LeetCode173.二叉搜索树迭代器</a></li>
<li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">LeetCode222.完全二叉树的节点个数</a></li>
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/">LeetCode226.翻转二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">LeetCode230.二叉搜索树中第K小的元素</a></li>
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">LeetCode297.二叉树的序列化与反序列化</a></li>
<li><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/">LeetCode352.将数据流变为多个不相交区间</a>（平衡二叉树TreeSet）</li>
<li><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">LeetCode404.左叶子之和</a></li>
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">LeetCode429.N叉树的层序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/">LeetCode449.序列化和反序列化二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">LeetCode450.删除二叉搜索树中的节点</a></li>
<li><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">LeetCode501.二叉搜索树中的众数</a></li>
<li><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">LeetCode513.找树左下角的值</a>（BFS）</li>
<li><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">LeetCode515.在每个树行中找最大值</a>（BFS）</li>
<li><a href="https://leetcode-cn.com/problems/even-odd-tree/">LeetCode1609.奇偶树</a>（BFS）</li>
</ul>
<h3 id="5trie树字典树">5.Trie树(字典树)</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">LeetCode208.实现Trie(前缀树)</a></li>
<li><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">LeetCode211.添加与搜索单词-数据结构设计</a></li>
<li><a href="https://leetcode-cn.com/problems/word-search-ii/">LeetCode212.单词搜索Ⅱ</a>（DFS+Trie优化）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">LeetCode421.数组中两个数的最大异或值</a></li>
</ul>
<h3 id="6堆">6.堆</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">LeetCode215.数组中的第K个最大元素</a>（TopK）</li>
<li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LeetCode295.数据流的中位数</a>（对顶堆）</li>
<li><a href="https://leetcode-cn.com/problems/sliding-window-median/">LeetCode480.滑动窗口中位数</a>（对顶堆）</li>
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LeetCode347.前K个高频元素</a>（TopK）</li>
<li><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">LeetCode373.查找和最小的K对数字</a>（TopK）</li>
<li><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LeetCode451.根据字符出现频率排序</a>（TopK）</li>
</ul>
<h3 id="7栈-队列">7.栈、队列</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/min-stack/">LeetCode155.最小栈</a>（设计）</li>
<li><a href="https://leetcode-cn.com/problems/backspace-string-compare/">LeetCode844.比较含退格的字符串</a></li>
<li><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/">LeetCode1381.设计一个支持增量操作的栈</a>（设计）</li>
<li><a href="https://leetcode-cn.com/problems/design-circular-queue/">LeetCode622.设计循环队列</a></li>
<li><a href="https://leetcode-cn.com/problems/design-circular-deque/">LeetCode641.设计循环双端队列</a></li>
<li><a href="https://leetcode-cn.com/problems/validate-stack-sequences/">LeetCode946.验证栈序列</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">LeetCode1047.删除字符串中的所有相邻重复项</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/">LeetCode1209.删除字符串中的所有相邻重复项II</a></li>
</ul>
<h4 id="71-转换">7.1 转换</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/implement-stack-using-queues">LeetCode225.用队列实现栈</a></li>
<li><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">LeetCode232.用栈实现队列</a></li>
</ul>
<h4 id="72-单调栈">7.2 单调栈</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/trapping-rain-water">LeetCode42.接雨水</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LeetCode84.柱状图中最大的矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/maximal-rectangle/">LeetCode85.最大矩形</a>（84拓展）</li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/">LeetCode496.下一个更大元素Ⅰ</a></li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">LeetCode503.下一个更大元素Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/daily-temperatures/">LeetCode739.每日温度</a></li>
</ul>
<h4 id="73-单调队列">7.3 单调队列</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/sliding-window-maximum">LeetCode239.滑动窗口最大值</a></li>
</ul>
<h4 id="74-逆波兰表达式计算器">7.4 逆波兰表达式/计算器</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation">LeetCode150.逆波兰表达式求值</a></li>
<li><a href="https://leetcode-cn.com/problems/basic-calculator">LeetCode224.基本计算器</a></li>
<li><a href="https://leetcode-cn.com/problems/basic-calculator-ii">LeetCode227.基本计算器Ⅱ</a></li>
</ul>
<h4 id="75-括号序列">7.5 括号序列</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/4sum">LeetCode20.有效的括号</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">LeetCode32.最长有效括号</a></li>
</ul>
<h3 id="8双指针">8.双指针</h3>
<h4 id="81-同向双指针">8.1 同向双指针</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-and-say/">LeetCode38.外观数列</a></li>
<li><a href="https://leetcode-cn.com/problems/length-of-last-word/">LeetCode58.最后一个单词长度</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">LeetCode26.删除排序数组中的重复项</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">LeetCode80.删除排序数组中的重复项Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-element/">LeetCode27.移除元素</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-colors/">LeetCode75.颜色分类</a>（三指针）</li>
<li><a href="https://leetcode-cn.com/problems/merge-sorted-array/">LeetCode88.合并两个有序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/move-zeroes/">LeetCode283.移动零</a></li>
<li><a href="https://leetcode-cn.com/problems/is-subsequence/">LeetCode392.判断子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">LeetCode434.字符串中的单词数</a></li>
<li><a href="https://leetcode-cn.com/problems/string-compression/">LeetCode443.压缩字符串</a></li>
<li><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">LeetCode485.最大连续1的个数</a></li>
<li><a href="https://leetcode-cn.com/problems/partition-labels/">LeetCode763.划分字母区间</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">LeetCode922.按奇偶排序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/interval-list-intersections/">LeetCode986.区间列表的交集</a></li>
</ul>
<h4 id="82-滑动窗口">8.2 滑动窗口</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">LeetCode3.无重复字符的最长子串</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-window-substring">LeetCode76.最小覆盖子串</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">LeetCode209.长度最小的子数组</a>（前缀和+双指针）</li>
<li><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">LeetCode424.替换后的最长重复字符</a></li>
<li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LeetCode438.找到字符串中所有字母异位词</a></li>
<li><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/">LeetCode532.数组中的k-diff数对</a></li>
<li><a href="https://leetcode-cn.com/problems/permutation-in-string/">LeetCode567.字符串的排列</a></li>
<li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">LeetCode1004.最大连续1的个数Ⅲ</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/">LeetCode1493.删掉一个元素以后全为1的最长子数组</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-erasure-value/">LeetCode1695.删除子数组的最大得分</a>（哈希表+滑动窗口）</li>
</ul>
<h4 id="83-逆向双指针">8.3 逆向双指针</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode5.最长回文子串</a></li>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/">LeetCode11.盛水最多的容器</a></li>
<li><a href="https://leetcode-cn.com/problems/3sum/">LeetCode15.三数之和</a></li>
<li><a href="https://leetcode-cn.com/problems/3sum-closest/">LeetCode16.最接近的三数之和</a></li>
<li><a href="https://leetcode-cn.com/problems/4sum">LeetCode18.四数之和</a></li>
<li><a href="https://leetcode-cn.com/problems/valid-palindrome/">LeetCode125.验证回文串</a></li>
<li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">LeetCode167.两数之和Ⅱ-输入有序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-string/">LeetCode344.反转字符串</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">LeetCode345.反转字符串中的元音字母</a></li>
</ul>
<h3 id="9哈希表">9.哈希表</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/group-anagrams/">LeetCode49.字母异位词分组</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">LeetCode128.最长连续序列</a></li>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate/">LeetCode217.存在重复元素</a></li>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">LeetCode219.存在重复元素Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">LeetCode220.存在重复元素Ⅲ</a></li>
<li><a href="https://leetcode-cn.com/problems/bulls-and-cows/">LeetCode299.猜数字游戏</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">LeetCode349.两个数组的交集</a></li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">LeetCode350.两个数组的交集Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">LeetCode380.常数时间插入、删除和获取随机元素</a></li>
<li><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">LeetCode381.O(1)时间插入、删除和获取随机元素-允许重复</a></li>
<li><a href="https://leetcode-cn.com/problems/ransom-note/">LeetCode383.赎金信</a></li>
<li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">LeetCode387.字符中的第一个唯一字符</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-palindrome/">LeetCode409.最长回文串</a></li>
<li><a href="https://leetcode-cn.com/problems/path-sum-iii/">LeetCode437.路径总和Ⅲ</a>（前缀和+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/4sum-ii/">LeetCode454.四数相加Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">LeetCode560.和为K的子数组</a>（前缀和+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/4sum-ii/">LeetCode454.四数相加Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode146.LRU缓存</a></li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">LeetCode460.LFU缓存</a></li>
<li><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">LeetCode523.连续子数组和</a>（前缀和+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/contiguous-array/">LeetCode525.连续数组</a>（前缀和+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/">LeetCode532.数组中的k-diff数对</a></li>
<li><a href="https://leetcode-cn.com/problems/brick-wall/">LeetCode554.砖墙</a></li>
<li><a href="https://leetcode-cn.com/problems/distribute-candies/">LeetCode575.分糖果</a></li>
<li><a href="https://leetcode-cn.com/problems/design-hashset/">LeetCode705.设计哈希集合</a></li>
<li><a href="https://leetcode-cn.com/problems/design-hashmap/">LeetCode706.设计哈希映射</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/">LeetCode1577.数的平方等于两数乘积的方法数</a></li>
<li><a href="https://leetcode-cn.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/">LeetCode1604.警告一小时内使用相同员工卡大于等于3次的人</a>（哈希表，排序）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-character-frequencies-unique">LeetCode1647.字符频次唯一的最小删除次数</a></li>
<li><a href="https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/">LeetCode1679.K和数对的最小数目</a>（哈希表/双指针）</li>
</ul>
<h3 id="10位运算">10.位运算</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/add-binary">LeetCode67.二进制求和</a>（高精度加法）</li>
<li><a href="https://leetcode-cn.com/problems/single-number/">LeetCode136.只出现一次的数字</a>（异或性质）</li>
<li><a href="https://leetcode-cn.com/problems/single-number-ii/">LeetCode137.只出现一次的数字Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/single-number-iii/">LeetCode260.只出现一次的数字Ⅲ</a>（分组异或）</li>
<li><a href="https://leetcode-cn.com/problems/missing-number/">LeetCode268.丢失的数字</a>（异或性质）</li>
<li><a href="https://leetcode-cn.com/problems/game-of-life/">LeetCode289.生命游戏</a>（二进制位存状态）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">LeetCode318.最大单词长度乘积</a>（二进制位存状态）</li>
<li><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">LeetCode371.两整数之和</a></li>
<li><a href="https://leetcode-cn.com/problems/find-the-difference/">LeetCode389.找不同</a>（异或性质）</li>
<li><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">LeetCode405.数字转换为十六进制数</a>（进制转换）</li>
<li><a href="https://leetcode-cn.com/problems/hamming-distance/">LeetCode461.汉明距离</a></li>
<li><a href="https://leetcode-cn.com/problems/number-complement/">LeetCode476.数字的补数</a></li>
<li><a href="https://leetcode-cn.com/problems/total-hamming-distance/">LeetCode477.汉明距离总和</a></li>
<li><a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">LeetCode1680.连接连续二进制数字</a>（位运算）</li>
</ul>
<h3 id="11排序">11.排序</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/insertion-sort-list/">LeetCode147.对链表进行插入排序</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-list/">LeetCode148.排序链表</a>（链表归并排序）</li>
<li><a href="https://leetcode-cn.com/problems/ugly-number-ii/">LeetCode264.丑数Ⅱ</a>（多路归并）</li>
<li><a href="https://leetcode-cn.com/problems/super-ugly-number/">LeetCode313.超级丑数</a>（多路归并）</li>
<li><a href="https://leetcode-cn.com/problems/sort-an-array/">LeetCode912.排序数组</a>（排序模板题）</li>
<li><a href="https://leetcode-cn.com/problems/relative-sort-array/">LeetCode1122.数组的相对排序</a>（自定义排序/计数排序）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/">LeetCode1464.数组中两元素的最大乘积</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/">LeetCode1465.切割后面积最大的蛋糕</a></li>
<li><a href="https://leetcode-cn.com/problems/sort-array-by-increasing-frequency/">LeetCode1636.按照频率将数组升序排序</a>（自定义排序）</li>
<li><a href="https://leetcode-cn.com/problems/widest-vertical-area-between-two-points-containing-no-points/">LeetCode1637.两点之间不包含任何点的垂直最宽面积</a></li>
</ul>
<h3 id="12数学">12.数学</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode43.字符串相乘</a>（高精度乘法）</li>
<li><a href="https://leetcode-cn.com/problems/powx-n/">LeetCode50.pow(x,n)</a>（快速幂）</li>
<li><a href="https://leetcode-cn.com/problems/permutation-sequence/">LeetCode60.排列序列</a>（字典序找位置）</li>
<li><a href="https://leetcode-cn.com/problems/add-binary/">LeetCode67.二进制求和</a>（二进制的高精度加法）</li>
<li><a href="https://leetcode-cn.com/problems/gray-code/">LeetCode89.格雷编码</a>（格雷码）</li>
<li><a href="https://leetcode-cn.com/problems/max-points-on-a-line/">LeetCode149.直线上最多的点数</a>（平面几何、斜率）</li>
<li><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">LeetCode166.分数到小数</a>（模拟除法找循环节）</li>
<li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">LeetCode172.阶乘后的零</a></li>
<li><a href="https://leetcode-cn.com/problems/largest-number/">LeetCode179.最大数</a>（自定义排序）</li>
<li><a href="https://leetcode-cn.com/problems/happy-number/">LeetCode202.快乐数</a>（快慢指针）</li>
<li><a href="https://leetcode-cn.com/problems/number-of-digit-one/">LeetCode233.数字1的个数</a>（计数问题）</li>
<li><a href="https://leetcode-cn.com/problems/ugly-number/">LeetCode263.丑数</a>（质因数分解）</li>
<li><a href="https://leetcode-cn.com/problems/count-primes/">LeetCode204.计数质数</a>（筛质数）</li>
<li><a href="https://leetcode-cn.com/problems/isomorphic-strings/">LeetCode205.同构字符串</a>（双射）</li>
<li><a href="https://leetcode-cn.com/problems/rectangle-area/">LeetCode223.矩形面积</a>（求面积）</li>
<li><a href="https://leetcode-cn.com/problems/add-digits/">LeetCode258.各位相加</a></li>
<li><a href="https://leetcode-cn.com/problems/word-pattern/">LeetCode270.单词规律</a>（双射）</li>
<li><a href="https://leetcode-cn.com/problems/nim-game/">LeetCode292.Nim游戏</a>（博弈论）</li>
<li><a href="https://leetcode-cn.com/problems/bulb-switcher/">LeetCode319.灯泡开关</a>（算数基本定理、约数）</li>
<li><a href="https://leetcode-cn.com/problems/power-of-two/">LeetCode231.2的幂</a></li>
<li><a href="https://leetcode-cn.com/problems/power-of-three/">LeetCode326.3的幂</a></li>
<li><a href="https://leetcode-cn.com/problems/power-of-four/">LeetCode342.4的幂</a></li>
<li><a href="https://leetcode-cn.com/problems/integer-break/">LeetCode343.整数拆分</a>（因数分解）</li>
<li><a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">LeetCode357.计算各个位数不同的数字个数</a>（计数问题）</li>
<li><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">LeetCode365.水壶问题</a>（裴蜀定理）</li>
<li><a href="https://leetcode-cn.com/problems/integer-replacement/">LeetCode397.整数替换</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/fizz-buzz/">LeetCode412.Fizz Buzz</a>（因数）</li>
<li><a href="https://leetcode-cn.com/problems/arithmetic-slices/">LeetCode415.字符串相加</a>（高精度加法）</li>
<li><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">LeetCode423.从英文中重建数字</a>（计数问题）</li>
<li><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">LeetCode440.字典序的第K小数字</a>（计数问题，模拟遍历十叉树）</li>
<li><a href="https://leetcode-cn.com/problems/arranging-coins/">LeetCode441.排列硬币</a></li>
<li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">LeetCode459.重复的子字符串</a>（循环节）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">LeetCode462.最少移动次数使数组元素相等Ⅱ</a>（中位数）</li>
<li><a href="https://leetcode-cn.com/problems/island-perimeter/">LeetCode463.岛屿的周长</a>（求平面图形周长）</li>
<li><a href="https://leetcode-cn.com/problems/construct-the-rectangle/">LeetCode492.构造矩形</a></li>
<li><a href="https://leetcode-cn.com/problems/the-kth-factor-of-n/">LeetCode1492.n的第k个因子</a>（因数）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal/">LeetCode1551.使数组中所有元素相等的最小操作数</a></li>
<li><a href="https://leetcode-cn.com/problems/kth-smallest-instructions">LeetCode1643.第K条最小指令</a>（字典序+组合数+计数问题）</li>
</ul>
<h3 id="13搜索">13.搜索</h3>
<h4 id="131-dfs">13.1 DFS</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">LeetCode17.电话号码的字母组合</a></li>
<li><a href="https://leetcode-cn.com/problems/generate-parentheses/">LeetCode22.括号生成</a></li>
<li><a href="https://leetcode-cn.com/problems/sudoku-solver">LeetCode37.解数独</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum">LeetCode39.组合总和</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum-ii">LeetCode40.组合总和Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/combination-sum-iii">LeetCode126.组合总和Ⅲ</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations">LeetCode46.全排列</a></li>
<li><a href="https://leetcode-cn.com/problems/permutations-ii">LeetCode47.全排列Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/n-queens">LeetCode51.N皇后</a></li>
<li><a href="https://leetcode-cn.com/problems/n-queens-ii">LeetCode52.N皇后Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/combinations">LeetCode77.组合</a></li>
<li><a href="https://leetcode-cn.com/problems/subsets/">LeetCode78.子集</a></li>
<li><a href="https://leetcode-cn.com/problems/subsets-ii/">LeetCode90.子集Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/word-search">LeetCode79.单词搜索</a></li>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">LeetCode93.复原IP地址</a></li>
<li><a href="https://leetcode-cn.com/problems/surrounded-regions/">LeetCode130.被围绕的区域</a>（Flood Fill）</li>
<li><a href="https://leetcode-cn.com/problems/clone-graph/">LeetCode133.克隆图</a></li>
<li><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">LeetCode138.复制带随机指针的链表</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">LeetCode301.删除无效的括号</a></li>
<li><a href="https://leetcode-cn.com/problems/lexicographical-numbers/">LeetCode386.字典序排数</a>（模拟遍历Trie树）</li>
<li><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">LeetCode417.太平洋大西洋水流问题</a>（Flood Fill）</li>
<li><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">LeetCode430.扁平化多级双向链表</a>（可看成二叉树的层序遍历）</li>
<li><a href="https://leetcode-cn.com/problems/island-perimeter/">LeetCode473.火柴拼正方形</a></li>
<li><a href="https://leetcode-cn.com/problems/letter-case-permutation/">LeetCode784.字母大小写全排列</a></li>
<li><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">LeetCode842.将数组拆分成斐波那契数列</a></li>
</ul>
<h4 id="132-bfs">13.2 BFS</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-ladder/">LeetCode127.单词接龙</a></li>
<li><a href="https://leetcode-cn.com/problems/word-ladder-ii/">LeetCode126.单词接龙Ⅱ</a>（BFS+DFS）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">LeetCode433.最小基因变化</a></li>
<li><a href="https://leetcode-cn.com/problems/employee-importance/">LeetCode690.员工的重要性</a>（BFS/DFS）</li>
</ul>
<h3 id="14贪心">14.贪心</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/jump-game/">LeetCode55.跳跃游戏</a></li>
<li><a href="https://leetcode-cn.com/problems/jump-game-ii/">LeetCode45.跳跃游戏Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/gas-station/">LeetCode124.加油站</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">LeetCode316.去除重复字母</a>（贪心+单调栈+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/patching-array/">LeetCode330.按要求补齐数组</a></li>
<li><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode376.摆动序列</a></li>
<li><a href="https://leetcode-cn.com/problems/remove-k-digits">LeetCode402.移掉K位数字</a>（贪心+单调栈）</li>
<li><a href="https://leetcode-cn.com/problems/assign-cookies/">LeetCode455.分发饼干</a></li>
<li><a href="https://leetcode-cn.com/problems/ipo/">LeetCode502.IPO</a>（贪心+堆）</li>
<li><a href="https://leetcode-cn.com/problems/can-place-flowers/">LeetCode605.种花问题</a></li>
<li><a href="https://leetcode-cn.com/problems/dota2-senate/">LeetCode649.Dota2参议院</a>（贪心+队列）</li>
<li><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">LeetCode659.分割数组为连续子序列</a>（贪心+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">LeetCode681.翻转矩阵后的得分</a>（基于操作顺序的贪心）</li>
<li><a href="https://leetcode-cn.com/problems/reorganize-string/">LeetCode767.重构字符串</a>（贪心+堆）</li>
<li><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">LeetCode738.单调递增是数字</a></li>
<li><a href="https://leetcode-cn.com/problems/lemonade-change/">LeetCode860.柠檬水找零</a></li>
<li><a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach">LeetCode1642.可以到达的最远建筑</a>（贪心+堆）</li>
<li><a href="https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls">LeetCode1648.销售价值减少的颜色球</a>（贪心+优化计算）</li>
<li><a href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/">LeetCode1673.找出最具竞争力的子序列</a>（贪心+单调栈，同402）</li>
</ul>
<h4 id="141-区间类贪心">14.1 区间类贪心</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">LeetCode435.无重叠区间</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons">LeetCode452.用最少数量的箭引爆气球</a></li>
<li><a href="https://leetcode-cn.com/problems/video-stitching">LeetCode1024.视频拼接</a></li>
</ul>
<h3 id="15分治">15.分治</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">LeetCode95.不同的二叉搜索树</a>（卡特兰数）</li>
<li><a href="">LeetCode241.为表达式设置优先级</a>（卡特兰数）</li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">LeetCode105.从前序和中序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">LeetCode106.从中序和后序遍历序列构造二叉树</a></li>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">LeetCode108.将有序数组转换为二叉搜索树</a></li>
<li><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">LeetCode109.有序链表转换二叉搜索树</a></li>
</ul>
<h3 id="16动态规划">16.动态规划</h3>
<h4 id="161-背包问题">16.1 背包问题</h4>
<h5 id="1611-01背包">16.1.1 01背包</h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">LeetCode416.分割等和子集</a></li>
<li><a href="https://leetcode-cn.com/problems/target-sum/">LeetCode494.目标和</a></li>
</ul>
<h5 id="1612-完全背包">16.1.2 完全背包</h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/perfect-squares">LeetCode279.完全平方数</a></li>
<li><a href="https://leetcode-cn.com/problems/coin-change">LeetCode322.零钱兑换</a></li>
<li><a href="https://leetcode-cn.com/problems/coin-change-2">LeetCode518.零钱兑换Ⅱ</a></li>
</ul>
<h5 id="1613-二维费用背包">16.1.3 二维费用背包</h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">LeetCode474.一和零</a></li>
</ul>
<h5 id="1614-求具体方案">16.1.4 求具体方案</h5>
<ul>
<li><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">LeetCode1449.数位成本和为目标值的最大数字</a></li>
</ul>
<h4 id="162-lis模型">16.2 LIS模型</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">LeetCode300.最长上升子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">LeetCode354.俄罗斯套娃信封问题</a>（二维LIS）</li>
<li><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">LeetCode368.最大整除子集</a>（LIS求方案）</li>
<li><a href="https://leetcode-cn.com/problems/best-team-with-no-conflicts">LeetCode1626.无矛盾的最佳球队</a>（二维LIS+LIS最大和）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-height-by-stacking-cuboids/">LeetCode1691.堆叠长方体的最大高度</a>（贪心+三维LIS）</li>
</ul>
<h4 id="163-线性dp">16.3 线性DP</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode53.最大子序和</a></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths">LeetCode62.不同路径</a></li>
<li><a href="https://leetcode-cn.com/problems/unique-paths-ii">LeetCode63.不同路径Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-path-sum">LeetCode64.最小路径和</a></li>
<li><a href="https://leetcode-cn.com/problems/climbing-stairs/">LeetCode70.爬楼梯</a>（递推）</li>
<li><a href="https://leetcode-cn.com/problems/edit-distance">LeetCode72.编辑距离</a></li>
<li><a href="https://leetcode-cn.com/problems/decode-ways/">LeetCode91.解码方法</a></li>
<li><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LeetCode96.不同的二叉搜索树</a>（递推）</li>
<li><a href="https://leetcode-cn.com/problems/interleaving-string/">LeetCode97.交错字符串</a></li>
<li><a href="https://leetcode-cn.com/problems/distinct-subsequences/">LeetCode115.不同的子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle">LeetCode118.杨辉三角</a></li>
<li><a href="https://leetcode-cn.com/problems/pascals-triangle-ii">LeetCode119.杨辉三角Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/triangle">LeetCode120.三角形最小路径和</a></li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">LeetCode131.分割回文串</a>（DP+DFS）</li>
<li><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">LeetCode132.分割回文串Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/dungeon-game/">LeetCode174.地下城游戏</a></li>
<li><a href="https://leetcode-cn.com/problems/maximal-square/">LeetCode221.最大正方形</a>（分类讨论）</li>
<li><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LeetCode376.摆动序列</a></li>
<li><a href="https://leetcode-cn.com/problems/fibonacci-number/">LeetCode509.斐波那契数</a></li>
<li><a href="https://leetcode-cn.com/problems/freedom-trail">LeetCode514.自由之路</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum">LeetCode1155.掷骰子的n种方法</a>（骰子问题）</li>
<li><a href="https://leetcode-cn.com/problems/constrained-subsequence-sum/">LeetCode1425.带限制的子序列和</a>（动态规划+单调队列优化）</li>
<li><a href="https://leetcode-cn.com/problems/jump-game-vi/">LeetCode1696.跳跃游戏VI</a>（动态规划+单调队列优化）</li>
</ul>
<p><strong>抢劫问题</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber">LeetCode198.打家劫舍</a></li>
<li><a href="https://leetcode-cn.com/problems/house-robber-ii">LeetCode213.打家劫舍Ⅱ</a></li>
</ul>
<p><strong>方格取数问题(矩阵双路径)</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/cherry-pickup">LeetCode741.摘樱桃</a></li>
<li><a href="https://leetcode-cn.com/problems/cherry-pickup-ii">LeetCode1463.摘樱桃Ⅱ</a></li>
</ul>
<p><strong>股票问题</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">LeetCode121.买卖股票的最佳时机</a>（贪心）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">LeetCode122.买卖股票的最佳时机Ⅱ</a>（贪心）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">LeetCode123.买卖股票的最佳时机Ⅲ</a>（前后缀分解也能做）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">LeetCode188.买卖股票的最佳时机Ⅳ</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">LeetCode309.最佳买卖股票时机含冷冻期</a>（状态机）</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">LeetCode714.买卖股票的最佳时机含手续费</a>（状态机）</li>
</ul>
<p><strong>表达式匹配</strong></p>
<ul>
<li><a href="https://leetcode-cn.com/problems/regular-expression-matching">LeetCode10.正则表达式匹配</a></li>
<li><a href="https://leetcode-cn.com/problems/wildcard-matching">LeetCode44.通配符匹配</a></li>
</ul>
<h4 id="164-区间dp">16.4 区间DP</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/burst-balloons">LeetCode312.戳气球</a></li>
<li><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii">LeetCode375.猜数字大小Ⅱ</a>（极小化极大，区间DP）</li>
<li><a href="https://leetcode-cn.com/problems/predict-the-winner/">LeetCode486.预测赢家</a>（极小化极大，区间DP）</li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">LeetCode516.最长回文子序列</a></li>
<li><a href="https://leetcode-cn.com/problems/stone-game/">LeetCode877.石子游戏</a>（博弈论，区间DP，数学，486题的特例）</li>
<li><a href="https://leetcode-cn.com/problems/stone-game-vii/">LeetCode1690.石子游戏Ⅶ</a>（博弈论，区间DP）</li>
</ul>
<h4 id="165-树形dp">16.5 树形DP</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/house-robber-iii">LeetCode337.打家劫舍Ⅲ</a></li>
</ul>
<h4 id="166-记忆化搜索">16.6 记忆化搜索</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/candy/">LeetCode135.分发糖果</a></li>
<li><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">LeetCode329.矩阵中的最长递增路径</a></li>
<li><a href="https://leetcode-cn.com/problems/can-i-win/">LeetCode464.我能赢吗</a>(状压DP+记忆化搜索)</li>
<li><a href="https://leetcode-cn.com/problems/cat-and-mouse/">LeetCode913.猫和老鼠</a>（存在平局的博弈论，记忆化搜索）</li>
<li><a href="https://leetcode-cn.com/problems/cat-and-mouse-ii/">LeetCode1728.猫和老鼠 II</a>（博弈论，记忆化搜索）</li>
</ul>
<h4 id="167-状态机dp">16.7 状态机DP</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">LeetCode309.最佳买卖股票时机含冷冻期</a>（状态机）</li>
<li><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">LeetCode552.学生出勤记录2</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">LeetCode714.买卖股票的最佳时机含手续费</a>（状态机）</li>
</ul>
<h4 id="168-状压dp">16.8 状压DP</h4>
<ul>
<li><a href="https://leetcode-cn.com/problems/can-i-win/">LeetCode464.我能赢吗</a>(状压DP+记忆化搜索)</li>
<li><a href="https://leetcode-cn.com/problems/minimum-incompatibility/">LeetCode1681.最小不兼容性</a>（枚举子集）</li>
</ul>
<h3 id="17图论">17.图论</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-islands/">LeetCode200.岛屿数量</a>（并查集+坐标变换）</li>
<li><a href="https://leetcode-cn.com/problems/course-schedule/">LeetCode207.课程表</a>（拓扑排序）</li>
<li><a href="https://leetcode-cn.com/problems/course-schedule-ii/">LeetCode210.课程表Ⅱ</a></li>
<li><a href="https://leetcode-cn.com/problems/minimum-height-trees/">LeetCode310.最小高度树</a>（BFS）</li>
<li><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">LeetCode332.重新安排行程</a>（欧拉路径）</li>
<li><a href="https://leetcode-cn.com/problems/evaluate-division/">LeetCode399.除法求值</a>（Floyd求最短路）</li>
<li><a href="https://leetcode-cn.com/problems/friend-circles/">LeetCode547.朋友圈</a>（并查集模板题）</li>
<li><a href="https://leetcode-cn.com/problems/redundant-connection/">LeetCode684.冗余连接</a>（并查集）</li>
<li><a href="https://leetcode-cn.com/problems/network-delay-time/">LeetCode743.网络延迟时间</a>（最短路模板题，可用来练习最短路算法：Dijkstra/Bellman-ford/SPFA/Floyd）</li>
<li><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">LeetCode785.判断二分图</a>（染色法判定二分图）</li>
<li><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">LeetCode797.所有可能的路径</a>（建图+DFS）</li>
<li><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">LeetCode990.等式方程的可满足性</a>（并查集）</li>
<li><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">LeetCode1584.连接所有点的最小费用</a>（最小生成树）</li>
<li><a href="https://leetcode-cn.com/problems/maximal-network-rank/">LeetCode1615.最大网络秩</a></li>
<li><a href="https://leetcode-cn.com/problems/graph-connectivity-with-threshold/">LeetCode1627.带阈值的图连通性</a>（并查集+数论）</li>
<li><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">LeetCode1631.最小体力消耗路径</a>（并查集+坐标变换/DFS+二分）</li>
<li><a href="https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/">LeetCode1697.检查边长度的路径是否存在</a>（离线算法+并查集）</li>
</ul>
<h3 id="18树状数组">18.树状数组</h3>
<ul>
<li><strong>一般用树状数组能解决的问题，都可以用归并排序变形来解决</strong></li>
<li><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/">LeetCode307.区域和检索-数组可修改</a>（树状数组模板题）</li>
<li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">LeetCode315.计算右侧小于当前元素的个数</a></li>
<li><a href="https://leetcode-cn.com/problems/count-of-range-sum/">LeetCode327.区间和的个数</a></li>
<li><a href="https://leetcode-cn.com/problems/reverse-pairs/">LeetCode493.翻转对</a></li>
<li><a href="https://leetcode-cn.com/problems/create-sorted-array-through-instructions/">LeetCode1649.通过指令创建有序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">剑指offer.51.数组中的逆序对</a></li>
</ul>
<h3 id="19蓄水池抽样">19.蓄水池抽样</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-random-node">LeetCode382.链表随机节点</a></li>
<li><a href="https://leetcode-cn.com/problems/random-pick-index">LeetCode398.随机数索引</a></li>
</ul>
<h3 id="20字符串">20.字符串</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">LeetCode5.最长回文子串</a>（中心扩展法）</li>
<li><a href="https://leetcode-cn.com/problems/detect-capital/">LeetCode520.检测大写字母</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">LeetCode521.最长特殊序列1</a>（脑筋急转弯）</li>
<li><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/">LeetCode522.最长特殊序列2</a>（双指针判定子序列）</li>
<li><a href="https://leetcode-cn.com/problems/student-attendance-record-i/">LeetCode551.学生出勤记录1</a></li>
<li><a href="https://leetcode-cn.com/problems/palindromic-substrings/">LeetCode647.回文子串</a>（中心扩展法）</li>
<li><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">LeetCode1332.删除回文子序列</a>（脑筋急转弯）</li>
<li><a href="https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/">LeetCode1637.统计只差一个字符的子串数目</a>（暴力枚举）</li>
</ul>
<hr>
<h3 id="leetcode第30场双周赛">LeetCode第30场双周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/reformat-date/">LeetCode1507.转换日期格式</a>（字符串API）</li>
<li><a href="https://leetcode-cn.com/problems/stone-game-iv/">LeetCode1510.石子游戏Ⅳ</a>(博弈论，DP)</li>
</ul>
<h3 id="leetcode第192场周赛">LeetCode第192场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/shuffle-the-array/">LeetCode1470.重新排列数组</a>（数组，模拟）</li>
<li><a href="https://leetcode-cn.com/problems/the-k-strongest-values-in-an-array/">LeetCode1471.数组中的k个最强值</a>（自定义排序）</li>
<li><a href="https://leetcode-cn.com/problems/design-browser-history/">LeetCode1472.设计浏览器历史记录</a>（设计）</li>
</ul>
<h3 id="leetcode第217场周赛">LeetCode第217场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/richest-customer-wealth/">LeetCode1673.最富有客户的资产总量</a>（统计行最大值）</li>
<li><a href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/">LeetCode1674.找出最具竞争力的子序列</a>（贪心+单调栈，同402题）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/">LeetCode1675.使数组互补的最少操作次数</a>（一维差分）</li>
</ul>
<h3 id="leetcode第218场周赛">LeetCode第218场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/">LeetCode1678.设计Goal解析器</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/">LeetCode1679.K和数对的最小数目</a>（哈希表/双指针）</li>
<li><a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">LeetCode1680.连接连续二进制数字</a>（位运算）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-incompatibility/">LeetCode1681.最小不兼容性</a>（枚举子集状压DP）</li>
</ul>
<h3 id="leetcode第219场周赛">LeetCode第219场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-of-matches-in-tournament/">LeetCode1688.比赛中的配对次数</a>（模拟/脑筋急转弯）</li>
<li><a href="https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/">LeetCode1689.十-二进制数的最少数目</a>（脑筋急转弯）</li>
<li><a href="https://leetcode-cn.com/problems/stone-game-vii/">LeetCode1690.石子游戏Ⅶ</a>（博弈论，区间DP）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-height-by-stacking-cuboids/">LeetCode1691.堆叠长方体的最大高度</a>（贪心+三维LIS）</li>
</ul>
<h3 id="leetcode第220场周赛">LeetCode第220场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/reformat-phone-number/">LeetCode1694.重新格式化电话号码</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-erasure-value/">LeetCode1695.删除子数组的最大得分</a>（哈希表+滑动窗口）</li>
<li><a href="https://leetcode-cn.com/problems/jump-game-vi/">LeetCode1696.跳跃游戏VI</a>（动态规划+单调队列优化）</li>
<li><a href="https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/">LeetCode1697.检查边长度的路径是否存在</a>（离线算法+并查集）</li>
</ul>
<h3 id="leetcode第221场周赛">LeetCode第221场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/">LeetCode1704.判断字符串的两半是否相似</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/">LeetCode1705.吃苹果的最大数目</a>（贪心+堆）</li>
<li><a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/">LeetCode1706.球会落何处</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">LeetCode1707.与数组中元素的最大异或值</a>（贪心+Trie树+离线，同421）</li>
</ul>
<h3 id="leetcode第222场周赛">LeetCode第222场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-units-on-a-truck/">LeetCode1710.卡车上的最大单元数</a>（贪心）</li>
<li><a href="https://leetcode-cn.com/problems/count-good-meals/">LeetCode1711.大餐计数</a>（哈希表，两数之和变形）</li>
<li><a href="https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/">LeetCode1712.将数组分成三个子数组的方案数</a>（前缀和+二分）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">LeetCode1713.得到子序列的最少操作次数</a>（LCS转换LIS+贪心优化）</li>
</ul>
<h3 id="leetcode第223场周赛">LeetCode第223场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/decode-xored-array/">LeetCode1720.解码异或后的数组</a>（异或运算性质）</li>
<li><a href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/">LeetCode1721.交换链表中的节点</a>（链表）</li>
<li><a href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/">LeetCode1722.执行交换操作后的最小汉明距离</a>（并查集）</li>
<li><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">LeetCode1723.完成所有工作的最短时间</a>（枚举子集，状压DP）</li>
</ul>
<h3 id="leetcode第224场周赛">LeetCode第224场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">LeetCode1725.可以形成最大正方形的矩形数目</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/tuple-with-same-product/">LeetCode1726.同积元组</a>（哈希表，数学，计数）</li>
<li><a href="https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/">LeetCode1727.重新排列后的最大子矩阵</a>（枚举，排序，第85题的简单版，可不用单调栈优化）</li>
<li><a href="https://leetcode-cn.com/problems/cat-and-mouse-ii/">LeetCode1728.猫和老鼠 II</a>（博弈论，记忆化搜索）</li>
</ul>
<h3 id="第45场双周赛">第45场双周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">LeetCode1748.唯一元素的和</a>（哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">LeetCode 1749.任意子数组和的绝对值的最大值</a>（动态规划，最大子序和问题）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">LeetCode 1750.删除字符串两端相同字符后的最短长度</a>（双指针）</li>
<li><a href="https://www.acwing.com/activity/content/problem/content/3478/1/">LeetCode 1751.最多可以参加的会议数目II</a>（动态规划+二分，区间问题）</li>
</ul>
<!-- ### 第227场周赛
* []()
* []()
* []()
* []() -->
<h3 id="第228场周赛">第228场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/">LeetCode1758.生成交替二进制字符串的最少操作数</a>（模拟/位运算）</li>
<li><a href="https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/">LeetCode1759.统计同构子字符串的数目</a>（滑窗+哈希表/计数问题）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">LeetCode1760.袋子里数目最少的球</a>（值域二分）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/">LeetCode1761.一个图中连通三元组的最小度数</a>（暴力枚举+预处理节点的度）</li>
</ul>
<h3 id="第229场周赛">第229场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/merge-strings-alternately/">交替合并字符串</a>（双指针，模拟）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/">移动所有球到每个盒子所需的最小操作数</a>（暴力）</li>
<li><a href="https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations/">执行乘法运算的最大分数</a>（区间DP）</li>
<li><a href="https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences/">由子序列构造的最长回文串的长度</a>（区间DP）</li>
</ul>
<h3 id="第230场周赛">第230场周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/">LeetCode1773. 统计匹配检索规则的物品数量</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/closest-dessert-cost/">LeetCode1774. 最接近目标价格的甜点成本</a>（0-1背包/三进制枚举/DFS）</li>
<li><a href="https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/">LeetCode1775. 通过最少操作次数使数组的和相等</a>（贪心）</li>
<li><a href="https://leetcode-cn.com/problems/car-fleet-ii/">LeetCode1776. 车队II</a>（单调栈）</li>
</ul>
<h3 id="第31场双周赛">第31场双周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range/">LeetCode1523. 在区间范围内统计奇数数目</a>（数学）</li>
<li><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/">LeetCode1524. 和为奇数的子数组数目</a>（前缀和）</li>
<li><a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/">LeetCode1525. 字符串的好分割数目</a>（线性扫描枚举分割点+哈希表）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">LeetCode1526. 形成目标数组的子数组最少增加次数</a>（差分数组）</li>
</ul>
<h3 id="第33场双周赛">第33场双周赛</h3>
<ul>
<li><a href="https://leetcode-cn.com/problems/thousand-separator/">LeetCode1556. 千位分隔数</a>（模拟）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/">LeetCode1557. 可以到达所有点的最少点数目</a>（图论，度的统计，有向无环图的性质）</li>
<li><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array/">LeetCode1558. 得到目标数组的最少函数调用次数</a>（贪心，模拟/位运算）</li>
<li><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid/">LeetCode1559. 二维网格图中探测环</a>（并查集）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基础算法代码模板]]></title>
        <id>https://Ryan-ovo.github.io/post/ji-chu-suan-fa-dai-ma-mo-ban/</id>
        <link href="https://Ryan-ovo.github.io/post/ji-chu-suan-fa-dai-ma-mo-ban/">
        </link>
        <updated>2021-04-13T05:13:56.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9">快速选择</a></li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="#%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E9%87%8F">求逆序对数量</a></li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
</ul>
</li>
<li><a href="#%E7%9F%A9%E9%98%B5">矩阵</a>
<ul>
<li><a href="#%E7%9F%A9%E9%98%B5%E6%97%8B%E8%BD%AC">矩阵旋转</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86">字符串处理</a>
<ul>
<li><a href="#%E5%B7%A6%E6%97%8B%E8%BD%ACk%E4%BD%8D">左旋转k位</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6">高精度</a>
<ul>
<li><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95">高精度加法</a></li>
<li><a href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95">高精度乘法</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E8%A1%A8">链表</a>
<ul>
<li><a href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">反转链表</a></li>
<li><a href="#%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC">两个一组反转</a></li>
<li><a href="#k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC">k个一组反转</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">排序两个有序链表</a></li>
<li><a href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并k个有序链表</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9%E4%BF%9D%E7%95%99%E4%B8%80%E4%B8%AA">删除重复节点(保留一个)</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9">删除重复节点</a></li>
</ul>
</li>
<li><a href="#%E6%A0%91">树</a>
<ul>
<li><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a></li>
<li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a></li>
<li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></li>
<li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a></li>
<li><a href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">重建二叉树</a></li>
<li><a href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca">最近公共祖先LCA</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C">判断树是否相同</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0">判断树是否对称</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E5%AD%90%E6%A0%91">判断子树</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">判断平衡二叉树</a></li>
<li><a href="#%E6%B1%82%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">求最小深度</a></li>
<li><a href="#%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">求最大深度</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">序列化与反序列化</a></li>
</ul>
</li>
<li><a href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97">栈与队列</a>
<ul>
<li><a href="#%E5%8D%95%E8%B0%83%E6%A0%88">单调栈</a></li>
<li><a href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97">单调队列</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">设计数据结构</a>
<ul>
<li><a href="#%E5%8F%8C%E9%93%BE%E8%A1%A8">双链表</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">循环队列</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">循环双端队列</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88">哈希集合</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84">哈希映射</a></li>
<li><a href="#lru">LRU</a></li>
<li><a href="#lru%E7%BC%93%E5%AD%98">LRU缓存</a></li>
<li><a href="#tire%E6%A0%91">Tire树</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E5%AD%A6">数学</a>
<ul>
<li><a href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2">大小写转换</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%B1%82%E5%92%8C">位运算求和</a></li>
<li><a href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95">埃氏筛法</a></li>
<li><a href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86">整数拆分</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%B9%82">快速幂</a></li>
<li><a href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a></li>
<li><a href="#%E6%B1%82%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AA%E6%95%B0">求三角形个数</a></li>
<li><a href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF">约瑟夫环</a></li>
</ul>
</li>
<li><a href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86">前缀和、差分</a>
<ul>
<li><a href="#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">一维前缀和</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">二维前缀和</a></li>
<li><a href="#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86">一维差分</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86">二维差分</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a>
<ul>
<li><a href="#10%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6">10进制转其他进制</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC10%E8%BF%9B%E5%88%B6">其他进制转10进制</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF">最短路</a>
<ul>
<li><a href="#dijkstra">Dijkstra</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86">数组处理</a>
<ul>
<li><a href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C%E6%83%85%E5%BD%A21%E6%B1%82%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">原地哈希情形1：求缺失的第一个正数</a></li>
<li><a href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C%E6%83%85%E5%BD%A22%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B41-n">原地哈希情形2：求数组中消失的数字，范围[1, n]</a></li>
<li><a href="#%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C%E6%83%85%E5%BD%A23%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B41-n">原地哈希情形3：求数组中重复的数字，范围[1, n]</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9">删除有序数组中的重复项</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="排序算法">排序算法</h3>
<h4 id="快速排序">快速排序</h4>
<pre><code class="language-c++">// 时间复杂度：O(nlogn)
void quick_sort(int l, int r){
    if(l == r) return;
    int x = q[(l + r) &gt;&gt; 1], i = l - 1, j = r + 1;
    while(i &lt; j){
        while(q[++i] &lt; x);
        while(q[--j] &gt; x);
        if(i &lt; j) swap(q[i], q[j]);
    }
    quick_sort(l, j);
    quick_sort(j + 1, r);
}
</code></pre>
<h4 id="快速选择">快速选择</h4>
<ul>
<li>选出第k小的元素</li>
</ul>
<pre><code class="language-c++">// 时间复杂度：O(n)
int quick_sort(int l, int r, int k){
    if(l == r) return q[l];
    int x = q[(l + r) &gt;&gt; 1], i = l - 1, j = r + 1;
    while(i &lt; j){
        while(q[++i] &lt; x);
        while(q[--j] &gt; x);
        if(i &lt; j) swap(q[i], q[j]);
    }
    int sl = j - l + 1;
    if(sl &gt;= k) return quick_sort(l, j, k);
    return quick_sort(j + 1, r, k - sl);
}
</code></pre>
<h4 id="归并排序">归并排序</h4>
<pre><code class="language-java">void merge_sort(int[] q, int l, int r){
    if(l &gt;= r) return;
    int mid = l + r &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int[] t = new int[r - l + 1];
    int i = l, j = mid + 1, k = 0;
    while(i &lt;= mid &amp;&amp; j &lt;= r){
        if(q[i] &lt;= q[j]) t[k++] = q[i++];
        else t[k++] = q[j++];
    } 
    while(i &lt;= mid) t[k++] = q[i++];
    while(j &lt;= r) t[k++] = q[j++];
    k = 0;
    for(i = l; i &lt;= r; i++){
        q[i] = t[k++];
    }
}
</code></pre>
<h4 id="求逆序对数量">求逆序对数量</h4>
<ul>
<li>归并排序的应用</li>
</ul>
<pre><code class="language-java">void merge_sort(int[] q, int l, int r){
    if(l &gt;= r) return;
    int mid = l + r &gt;&gt; 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int[] t = new int[r - l + 1];
    int i = l, j = mid + 1, k = 0;
    while(i &lt;= mid &amp;&amp; j &lt;= r){
        if(q[i] &lt;= q[j]) t[k++] = q[i++];
        else {
            res += mid - i + 1;
            t[k++] = q[j++];
        }
    } 
    while(i &lt;= mid) t[k++] = q[i++];
    while(j &lt;= r) t[k++] = q[j++];
    k = 0;
    for(i = l; i &lt;= r; i++){
        q[i] = t[k++];
    }
}
</code></pre>
<h4 id="堆排序">堆排序</h4>
<ul>
<li>节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的左儿子为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>u</mi></mrow><annotation encoding="application/x-tex">2u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">u</span></span></span></span>, 右儿子为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2u+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>插入一个数：<code>h[++cnt] = x; up(cnt);</code></li>
<li>求堆顶：<code>h[1]</code></li>
<li>删除堆顶：<code>h[1] = h[cnt--]; down(1)</code></li>
</ul>
<pre><code class="language-java">// 初始化
int[] nums; //原数组
int[] h; //下标从1开始
int cnt; // 堆中的元素个数

// 第一种初始化方式：O(n)
cnt = n;
for(int i = 1; i &lt;= n; i++) h[i] = nums[i - 1];
for(int i = n / 2; i &gt;= 1; i--) down(i);

//第二种初始化方式：O(nlogn)
for(int i = 0; i &lt; n; i++){
    h[++cnt] = nums[i];
    up(cnt);
}

// 记录排序结果
for(int i = 0; i &lt; n; i++){
    res[i] = h[1]; //获取堆顶
    h[1] = h[cnt--]; //删除堆顶
    down(1); //堆顶下沉
}

// down函数
void down(int u){
    int k = u; //k记录当前节点u与左右儿子中的最小点
    if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[k]) k = u * 2;
    if(u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[k]) k = u * 2 + 1;
    if(u != k){
        int t = h[k];
        h[k] = h[u];
        h[u] = t;
        down(t); //下沉最小点直到无法下沉
    } 
}

//up函数
void up(int u){
    while(u / 2 &gt;= 1 &amp;&amp; h[u] &lt; h[u / 2]){
        int t = h[u];
        h[u] = h[u / 2];
        h[u / 2] = t;
        u /= 2;
    }
}
</code></pre>
<h3 id="矩阵">矩阵</h3>
<h4 id="矩阵旋转">矩阵旋转</h4>
<ul>
<li>顺时针旋转90°：先沿主对角线翻转，然后从中间水平翻转</li>
<li>逆时针旋转90°：先沿主对角线翻转，然后从中间上下翻转</li>
<li>顺时针旋转180°/逆时针旋转180°：先沿主对角线翻转，再沿副对角线翻转</li>
</ul>
<pre><code class="language-c++">// 以顺时针旋转90°为例
// 两种选择方式任选其一
// 选中矩阵主对角线左下方的区域
for(int i = 0; i &lt; n; i++){
    for(int j = 0; j &lt; i; j++){
        swap(a[i][j], a[j][i]);
    }
}

// 选中矩阵主对角线右上方的区域
for(int i = 0; i &lt; n; i++){
    for(int j = i + 1; j &lt; n; j++){
        swap(a[i][j], a[j][i]);
    }
}

// 沿对称轴左右翻转
for(int i = 0; i &lt; n; i++){
    for(int j = 0, k = n - 1; j &lt; k; j++, k--){
        swap(a[i][j], a[i][k]);
    }
}
</code></pre>
<h3 id="字符串处理">字符串处理</h3>
<h4 id="左旋转k位">左旋转k位</h4>
<pre><code class="language-c++">// k = 2, abcdefg -&gt; gfedcab
string reverseLeftWords(string s, int k) {
    int n = s.size();
    reverse(s.begin(), s.end());
    reverse(s.begin(), s.begin() + n - k);
    reverse(s.begin() + n - k, s.end());
    return s;
}
</code></pre>
<h3 id="高精度">高精度</h3>
<h4 id="高精度加法">高精度加法</h4>
<pre><code class="language-java">class Solution {
    public String addStrings(String a, String b) {
        int i = a.length()-1, j = b.length()-1, carry = 0;
        StringBuilder res = new StringBuilder();
        while(i &gt;= 0 || j &gt;= 0 || carry != 0){
            int n = 0, m = 0;
            if(i &gt;= 0) n = a.charAt(i) - '0';
            if(j &gt;= 0) m = b.charAt(j) - '0';
            int add = n + m + carry;
            res.append(add % 10);
            carry = add / 10;
            i--; j--;
        }
        return res.reverse().toString();
    }
}
</code></pre>
<h4 id="高精度乘法">高精度乘法</h4>
<pre><code class="language-java">class Solution {
    public String multiply(String num1, String num2) {
        int n = num1.length(), m = num2.length();
        int[] a = new int[n];
        int[] b = new int[m];
        for(int i = n-1; i &gt;= 0; i--) a[n-i-1] = num1.charAt(i) - '0';
        for(int i = m-1; i &gt;= 0; i--) b[m-i-1] = num2.charAt(i) - '0';
        int[] c = new int[n + m];
        for(int i = 0; i &lt; n; i++){
            for(int j = 0; j &lt; m; j++){
                c[i+j] += a[i] * b[j];
            }
        }
        int carry = 0;
        for(int i = 0; i &lt; n + m - 1 || carry != 0; i++){
            int t = c[i] + carry;
            c[i] =  t % 10;
            carry = t / 10;
        }
        int k = n + m - 1;
        while(k &gt; 0 &amp;&amp; c[k] == 0) k--;
        StringBuilder res = new StringBuilder();
        while(k &gt;= 0) res.append(c[k--]);
        return res.toString();
    }
}
</code></pre>
<h3 id="链表">链表</h3>
<h4 id="反转链表">反转链表</h4>
<ul>
<li>非递归</li>
</ul>
<pre><code class="language-java">// 整条反转
public ListNode reverseList(ListNode head) {
    if(head == null || head.next == null) return head;
    ListNode a = head, b = a.next;
    while(b != null){
        ListNode c = b.next;
        b.next = a;
        a = b;
        b = c;
    }
    head.next = null;
    return a;
}

// 反转中间一段m-n
// [1, 2, 3, 4, 5], m = 2, n = 4, [1, 4, 3, 2, 5]
public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode o = dummy;
    for(int i = 0; i &lt; m-1; i++) o = o.next;
    ListNode a = o.next;
    ListNode b = a.next;
    for(int i = 0; i &lt; n-m; i++){
        ListNode c = b.next;
        b.next = a;
        a = b;
        b = c;
    }
    o.next.next = b;
    o.next = a;
    return dummy.next;
}
</code></pre>
<ul>
<li>递归</li>
</ul>
<pre><code class="language-java">class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
}
</code></pre>
<h4 id="两个一组反转">两个一组反转</h4>
<pre><code class="language-java">public ListNode swapPairs(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode cur = dummy;
    while(cur.next != null &amp;&amp; cur.next.next != null){
        ListNode a = cur.next, b = a.next;
        a.next = b.next;
        b.next = a;
        cur.next = b;
        cur = a;
    }
    return dummy.next;
}
</code></pre>
<h4 id="k个一组反转">k个一组反转</h4>
<pre><code class="language-java">public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode cur = dummy;
    int n = 0;
    for(ListNode p = head; p != null; p = p.next) n++;
    for(int i = 0; i &lt; n / k; i++){
        ListNode a = cur.next, b = a.next;
        for(int j = 0; j &lt; k - 1; j++){
            ListNode c = b.next;
            b.next = a;
            a = b;
            b = c;
        }
        ListNode t = cur.next;
        cur.next.next = b;
        cur.next = a;
        cur = t;
    }
    return dummy.next;
}
</code></pre>
<h4 id="排序两个有序链表">排序两个有序链表</h4>
<pre><code class="language-java">class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while(l1 != null &amp;&amp; l2 != null){
            if(l1.val &lt;= l2.val){
                cur = cur.next = l1;
                l1 = l1.next;
            }else{
                cur = cur.next = l2;
                l2 = l2.next;
            }
        }
        if(l1 != null) cur.next = l1;
        else cur.next = l2;
        return dummy.next;
    }
}
</code></pre>
<h4 id="合并k个有序链表">合并k个有序链表</h4>
<pre><code class="language-java">class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        int n = lists.length;
        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);
        for(ListNode node: lists) {
            if(node != null) heap.offer(node);
        }
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while(heap.size() &gt; 0){
            ListNode t = heap.poll();
            cur = cur.next = t;
            if(t.next != null) heap.offer(t.next);
        }
        return dummy.next;
    }
}
</code></pre>
<h4 id="删除重复节点保留一个">删除重复节点(保留一个)</h4>
<ul>
<li>头节点一定不会被删除，所以不需要虚拟头节点</li>
</ul>
<pre><code class="language-java">public ListNode deleteDuplicates(ListNode head) {
    ListNode cur = head;
    while(cur != null &amp;&amp; cur.next != null){
        if(cur.val == cur.next.val){
            cur.next = cur.next.next;
        }else{
            cur = cur.next;
        }
    }
    return head;
}
</code></pre>
<h4 id="删除重复节点">删除重复节点</h4>
<ul>
<li>头节点可能会被删除，需要虚拟头节点</li>
</ul>
<pre><code class="language-java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = dummy;
        while(cur.next != null){
            ListNode p = cur.next;
            while(p.next != null &amp;&amp; p.next.val == p.val) p = p.next;
            if(cur.next == p){
                cur = cur.next;
            }else{
                cur.next = p.next;
            }
        }
        return dummy.next;
    }
}
</code></pre>
<h3 id="树">树</h3>
<h4 id="层序遍历">层序遍历</h4>
<pre><code class="language-java">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    if(root == null) return res;
    Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root);
    while(q.size() != 0){
        int cnt = q.size();
        while(cnt-- &gt; 0){
            TreeNode t = q.poll();
            list.add(t.val);
            if(t.left != null) q.offer(t.left);
            if(t.right != null) q.offer(t.right);
        }
        res.add(new ArrayList&lt;&gt;(list));
        list.clear();
    }
    return res;
}
</code></pre>
<h4 id="前序遍历">前序遍历</h4>
<pre><code class="language-java">// 根左右
public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    Deque&lt;TreeNode&gt; stk = new ArrayDeque&lt;&gt;();
    while(stk.size() &gt; 0 || root != null){
        while(root != null){
            stk.push(root);
            res.add(root.val);
            root = root.left;
        }
        root = stk.pop();
        root = root.right;
    }
    return res;
}
</code></pre>
<h4 id="中序遍历">中序遍历</h4>
<pre><code class="language-java">// 左根右
public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    Deque&lt;TreeNode&gt; stk = new ArrayDeque&lt;&gt;();
    while(stk.size() &gt; 0 || root != null){
        while(root != null){
            stk.push(root);
            root = root.left;
        }
        root = stk.pop();
        res.add(root.val);
        root = root.right;
    }
    return res;
}
</code></pre>
<h4 id="后序遍历">后序遍历</h4>
<pre><code class="language-java">// 左右根 = 根右左 -&gt; reverse
public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    Deque&lt;TreeNode&gt; stk = new ArrayDeque&lt;&gt;();
    while(stk.size() &gt; 0 || root != null){
        while(root != null){
            res.add(root.val);
            stk.push(root);
            root = root.right;
        }
        root = stk.pop();
        root = root.left;
    }
    Collections.reverse(res);
    return res;
}
</code></pre>
<h4 id="重建二叉树">重建二叉树</h4>
<pre><code class="language-java">// 记录中序遍历每个值对应的下标
for(int i = 0; i &lt; n; i++){
    map.put(inorder[i], i);
}

// 前序中序重建二叉树
TreeNode build(int[] preorder, int[] inorder, int pl, int pr, int il, int ir){
    if(pl &gt; pr || il &gt; ir) return null;
    TreeNode root = new TreeNode(preorder[pl]);
    int k = map.get(preorder[pl]);
    root.left = build(preorder, inorder, pl + 1, k - il + pl, il, k - 1);
    root.right = build(preorder, inorder, k - il + pl + 1, pr, k + 1, ir);
    return root;
}
</code></pre>
<h4 id="最近公共祖先lca">最近公共祖先LCA</h4>
<pre><code class="language-java">// 二叉搜索树
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(p == root || q == root) return root;
    if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q);
    if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}

// 普通二叉树
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left == null) return right;
    if(right == null) return left;
    return root;
}
</code></pre>
<h4 id="判断树是否相同">判断树是否相同</h4>
<pre><code class="language-java">public boolean isSameTree(TreeNode p, TreeNode q) {
    if(p == null &amp;&amp; q == null) return true;
    if(p == null || q == null) return false;
    if(p.val != q.val) return false;
    return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); 
}
</code></pre>
<h4 id="判断树是否对称">判断树是否对称</h4>
<pre><code class="language-java">public boolean isSymmetric(TreeNode root) {
    return check(root, root);
}

// 转换为两棵树是否对称
boolean check(TreeNode p, TreeNode q){
    if(p == null &amp;&amp; q == null) return true;
    if(p == null || q == null) return false;
    if(p.val != q.val) return false;
    return check(p.left, q.right) &amp;&amp; check(p.right, q.left);
}
</code></pre>
<h4 id="判断子树">判断子树</h4>
<pre><code class="language-java">// 判断B是否是A的子树
// 时间复杂度O(n)
public boolean isSubStructure(TreeNode A, TreeNode B) {
    if(A == null || B == null) return false;
    if(check(A, B)) return true;
    return isSubStructure(A.left, B) || isSubStructure(A.right, B);
}

boolean check(TreeNode p, TreeNode q){
    if(q == null) return true;
    if(p == null) return false;
    if(p.val != q.val) return false;
    return check(p.left, q.left) &amp;&amp; check(p.right, q.right);
}
</code></pre>
<h4 id="判断平衡二叉树">判断平衡二叉树</h4>
<pre><code class="language-java">boolean res = true;
public boolean isBalanced(TreeNode root) {
    dfs(root);
    return res;
}
// 后序遍历，自底向上
int dfs(TreeNode root){
    if(root == null) return 0;
    int lh = dfs(root.left);
    int rh = dfs(root.right);
    if(Math.abs(lh - rh) &gt; 1) res = false;
    return Math.max(lh, rh) + 1;
}
</code></pre>
<h4 id="求最小深度">求最小深度</h4>
<ul>
<li>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</li>
</ul>
<pre><code class="language-java">public int minDepth(TreeNode root) {
    if(root == null) return 0;
    if(root.left == null &amp;&amp; root.right == null) return 1;
    int minv = Integer.MAX_VALUE;
    if(root.left != null) minv = Math.min(minv, minDepth(root.left));
    if(root.right != null) minv = Math.min(minv, minDepth(root.right));
    return minv + 1;
}
</code></pre>
<h4 id="求最大深度">求最大深度</h4>
<ul>
<li>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</li>
</ul>
<pre><code class="language-java">public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
<h4 id="序列化与反序列化">序列化与反序列化</h4>
<pre><code class="language-java">public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder s = new StringBuilder();
        dfs1(root, s);
        System.out.print(s);
        return s.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        return dfs2(new StringBuilder(data));
    }

    void dfs1(TreeNode root, StringBuilder s){
        if(root == null){
            s.append(&quot;#,&quot;);
            return;
        }

        s.append(root.val).append(&quot;,&quot;);
        dfs1(root.left,s);
        dfs1(root.right,s);
    }

    TreeNode dfs2(StringBuilder data){
        if(data.charAt(0) == '#'){
            data.delete(0,2);
            return null;
        }
        boolean minus = false;
        if(data.charAt(0) == '-') {
            data.delete(0,1);
            minus = true;
        }
        int sum = 0;
        while(data.charAt(0) != ','){
            sum = sum * 10 + data.charAt(0) - '0';
            data.delete(0,1);
        }
        data.delete(0,1);
        if(minus) sum = -sum;
        TreeNode root = new TreeNode(sum);
        root.left = dfs2(data);
        root.right = dfs2(data);
        return root;
    }
}
</code></pre>
<h3 id="栈与队列">栈与队列</h3>
<h4 id="单调栈">单调栈</h4>
<pre><code class="language-java">// 求左侧第一个比a[i]小的数下标
for(int i = 0; i &lt; n; i++){
    while(stk.size() &gt; 0 &amp;&amp; a[stk.peek()] &gt;= a[i]) stk.pop();
    left[i] = stk.size() == 0 ? -1 : stk.peek();
    stk.push(i);
}

// 求右侧第一个比a[i]小的数下标
for(int i = n - 1; i &gt;= 0; i--){
    while(stk.size() &gt; 0 &amp;&amp; a[stk.peek()] &gt;= a[i]) stk.pop();
    right[i] = stk.size() == 0 ? n : stk.peek();
    stk.push(i);
}
</code></pre>
<h4 id="单调队列">单调队列</h4>
<pre><code class="language-java">// 求nums中所有长度为k窗口的最大值
for(int i = 0; i &lt; n; i++){
    if(dq.size() &gt; 0 &amp;&amp; i - dq.peekFirst() == k) dq.pollFirst();
    while(dq.size() &gt; 0 &amp;&amp; nums[i] &gt;= nums[dq.peekLast()]) dq.pollLast();
    dq.offerLast(i);
    if(i &gt;= k - 1) res[j++] = nums[dq.peekFirst()]; 
}
</code></pre>
<h3 id="设计数据结构">设计数据结构</h3>
<h4 id="双链表">双链表</h4>
<pre><code class="language-java">class MyLinkedList {
    class Node{
        int val;
        Node next;
        Node prev;
        public Node(){}
        public Node(int val){
            this.val = val;
        }
    }

    Node head = new Node(-1);
    Node tail = new Node(-1);
    
    int size = 0;

    /** Initialize your data structure here. */
    public MyLinkedList() {
        head.next = tail;
        tail.prev = head;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    public int get(int index) {
        Node p = head;
        for(int i = 0; i &lt; index + 1; i++){
            p = p.next;
        }
        if(p == tail || p == null) return -1;
        return p.val;
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    public void addAtHead(int val) {
        Node t = new Node(val);
        t.prev = head;
        t.next = head.next;
        head.next.prev = t;
        head.next = t;
        size++;
    }
    
    /** Append a node of value val to the last element of the linked list. */
    public void addAtTail(int val) {
        Node t = new Node(val);
        t.prev = tail.prev;
        t.next = tail;
        tail.prev.next = t;
        tail.prev = t;
        size++;
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    public void addAtIndex(int index, int val) {
        if(index &lt; 0) {
            addAtHead(val);
            return;
        }
        if(index &gt; size) return;

        Node p = head;
        for(int i = 0; i &lt; index; i++){
            p = p.next;
        }
        Node t = new Node(val);
        t.prev = p;
        t.next = p.next;
        p.next.prev = t;
        p.next = t;
        size++;
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    public void deleteAtIndex(int index) {
        Node p = head;
        for(int i = 0; i &lt; index + 1; i++){
            p = p.next;
        }
        if(p == tail || p == null) return;

        Node a = p.prev, b = p.next;
        a.next = b;
        b.prev = a;
        size--;
    }
}
</code></pre>
<h4 id="循环队列">循环队列</h4>
<pre><code class="language-java">class MyCircularQueue {
    int[] q;
    int front = 0, rear = 0;
    int n;
    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        q = new int[k+1];
        n = k + 1;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if((rear+1) % n == front) return false;
        q[rear] = value;
        rear = (rear + 1) % n;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if(front == rear) return false;
        front = (front+1)%n; 
        return true;
    }
    
    /** Get the front item from the queue. */
    public int Front() {
        if(front == rear) return -1;
        return q[front];
    }
    
    /** Get the last item from the queue. */
    public int Rear() {
        if(front == rear) return -1;
        return q[(rear-1+n) % n];
    }
    
    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        return front == rear;
    }
    
    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        return (rear+1) % n == front;
    }
}
</code></pre>
<h4 id="循环双端队列">循环双端队列</h4>
<pre><code class="language-java">class MyCircularDeque {
    int[] q;
    int n;
    int front = 0, rear = 0;
    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        n = k + 1;
        q = new int[n];
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if((rear+1)%n == front) return false;
        front = (front-1+n) % n;
        q[front] = value;
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if((rear+1)%n == front) return false;
        q[rear] = value;
        rear = (rear+1) % n;
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if(front == rear) return false;
        front = (front+1) % n;
        return true;
    }
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if(front == rear) return false;
        rear = (rear-1+n) % n;
        return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if(front == rear) return -1;
        return q[front];
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if(front == rear) return -1;
        return q[(rear-1+n)%n];
    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return front == rear;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return (rear+1) % n == front;
    }
}
</code></pre>
<h4 id="哈希集合">哈希集合</h4>
<pre><code class="language-java">// 拉链法
class MyHashSet {
    int base = 769;
    LinkedList&lt;Integer&gt;[] data = new LinkedList[base];
    /** Initialize your data structure here. */
    public MyHashSet() {
        for(int i = 0; i &lt; base; i++){
            data[i] = new LinkedList&lt;&gt;();
        }
    }
    
    public void add(int key) {
        int hash = key % base;
        for(int x: data[hash]){
            if(x == key) return;
        }
        data[hash].offerLast(key);
    }
    
    public void remove(int key) {
        int hash = key % base;
        for(int x: data[hash]){
            if(x == key) {
                data[hash].remove((Integer)x);
                return;
            }
        }
    }
    
    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        int hash = key % base;
        for(int x: data[hash]){
            if(x == key) return true;
        }
        return false;
    }
}
</code></pre>
<h4 id="哈希映射">哈希映射</h4>
<pre><code class="language-java">class MyHashMap {
    class Pair{
        int x;
        int y;
        public Pair(int x, int y){
            this.x = x;
            this.y = y;
        }
    }
    int base = 769;
    LinkedList&lt;Pair&gt;[] data = new LinkedList[base];
    /** Initialize your data structure here. */
    public MyHashMap() {
        for(int i = 0; i &lt; base; i++){
            data[i] = new LinkedList&lt;&gt;();
        }
    }
    
    /** value will always be non-negative. */
    public void put(int key, int value) {
        int hash = key % base;
        Pair p = new Pair(key, value);
        Iterator&lt;Pair&gt; it = data[hash].iterator();
        while(it.hasNext()){
            Pair t = it.next();
            if(t.x == key) {
                t.y = value;
                return;
            }
        }
        data[hash].offerLast(p);
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    public int get(int key) {
        int hash = key % base;
        Iterator&lt;Pair&gt; it = data[hash].iterator();
        while(it.hasNext()){
            Pair t = it.next();
            if(t.x == key){
                return t.y;
            }
        }
        return -1;
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    public void remove(int key) {
        int hash = key % base;
        Iterator&lt;Pair&gt; it = data[hash].iterator();
        while(it.hasNext()){
            Pair t = it.next();
            if(t.x == key){
                data[hash].remove(t);
                return;
            }
        }
    }
}
</code></pre>
<h4 id="lru">LRU</h4>
<h4 id="lru缓存">LRU缓存</h4>
<pre><code class="language-java">class LRUCache {
    class Node{
        int key;
        int value;
        Node left;
        Node right;
        public Node(int key, int value){
            this.key = key;
            this.value = value;
        }
    }
    Map&lt;Integer,Node&gt; map = new HashMap&lt;&gt;();
    Node head = new Node(-1, -1);
    Node tail = new Node(-1, -1);
    int n; // 最大容量
    public LRUCache(int capacity) {
        head.right = tail;
        tail.left = head;
        n = capacity;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            Node p = map.get(key);
            // get视为使用过，放到链表头
            remove(p);
            insert(p);
            return p.value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if(map.containsKey(key)){
            // 节点已经存在，修改值
            Node p = map.get(key);
            p.value = value;
            remove(p);
            insert(p);
        }else{
            // 新节点
            Node p = new Node(key, value);
            if(map.size() == n){
                // LRU满，移除链表尾和map中的相应节点
                Node t = tail.left;
                map.remove(t.key);
                remove(t);
            }
            map.put(key, p);
            insert(p);
        }
    }

    // 双链表中插入节点
    public void insert(Node p){
        p.left = head;
        p.right = p.left.right;
        p.right.left = p;
        p.left.right = p;
    }
    // 双链表中删除节点
    public void remove(Node p){
        p.left.right = p.right;
        p.right.left = p.left;
    }
}
</code></pre>
<h4 id="tire树">Tire树</h4>
<pre><code class="language-java">class Trie {
    class Node{
        Node[] son = new Node[26];
        boolean isEnd;
    }
    Node root;
    /** Initialize your data structure here. */
    public Trie() {
        root = new Node();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Node p = root;
        for(char c: word.toCharArray()){
            int u = c - 'a';
            if(p.son[u] == null) p.son[u] = new Node();
            p = p.son[u];
        }
        p.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Node p = root;
        for(char c: word.toCharArray()){
            int u = c - 'a';
            if(p.son[u] == null) return false;
            p = p.son[u];
        }
        return p.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String word) {
        Node p = root;
        for(char c: word.toCharArray()){
            int u = c - 'a';
            if(p.son[u] == null) return false;
            p = p.son[u];
        }
        return true;
    }
}
</code></pre>
<h3 id="数学">数学</h3>
<h4 id="大小写转换">大小写转换</h4>
<pre><code class="language-java">'a' ^ 32 == 'A'
'A' ^ 32 == 'a'
</code></pre>
<h4 id="位运算求和">位运算求和</h4>
<pre><code class="language-java">public int add(int a, int b) {
    while(b != 0){
        int sum = a ^ b;
        int carry = (a &amp; b) &lt;&lt; 1;
        a = sum;
        b = carry;
    }
    return a;
}
</code></pre>
<h4 id="埃氏筛法">埃氏筛法</h4>
<pre><code class="language-java">// 求小于n的所有质数
public List&lt;Integer&gt; getPrimes(int n) {
    int res = 0;
    List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    boolean[] st = new boolean[n + 1];
    for(int i = 2; i &lt; n; i++){
        if(st[i]) continue;
        res++;
        primes.add(i);
        for(int j = i * 2; j &lt; n; j += i){
            st[j] = true;
        }
    }
    return primes;
}
</code></pre>
<h4 id="整数拆分">整数拆分</h4>
<pre><code class="language-java">// 将整数拆成a1, a2, ... an，使得a1 * a2 * ... * an最大
public int integerBreak(int n) {
    if(n &lt;= 3) return n - 1;
    int a = n / 3, b = n % 3;
    if(b == 0) return (int)Math.pow(3, a);
    else if(b == 1) return (int)Math.pow(3, a - 1) * 4;
    else return (int)Math.pow(3, a) * 2;
}
</code></pre>
<h4 id="快速幂">快速幂</h4>
<pre><code class="language-java">//求a^k mod p
long pow(long a, long k, long p){
    long res = 1;
    while(k != 0){
        if((k &amp; 1) == 1) res = (res * a) % p;
        k &gt;&gt;= 1;
        a = a * a % p;
    }
    return res;
}
</code></pre>
<h4 id="欧几里得算法">欧几里得算法</h4>
<pre><code class="language-java">int gcd(int a, int b){
    return b != 0 ? gcd(b, a % b) : a;
}
</code></pre>
<h4 id="求三角形个数">求三角形个数</h4>
<pre><code class="language-java">// 双指针
public int triangleNumber(int[] nums) {
    int n = nums.length;
    Arrays.sort(nums);
    int res = 0;
    for(int i = n - 1; i &gt;= 2; i--){
        int l = 0, r = i - 1;
        while(l &lt; r){
            if(nums[l] + nums[r] &gt; nums[i]){
                res += r - l;
                r--;
            }else {
                l++;
            }
        }
    }
    return res;
}
</code></pre>
<h4 id="约瑟夫环">约瑟夫环</h4>
<pre><code class="language-java">int f(int n, int k) {
    if (n == 1) return 0;
    return (f(n - 1, k) + k) % n;
}
</code></pre>
<h3 id="前缀和-差分">前缀和、差分</h3>
<h4 id="一维前缀和">一维前缀和</h4>
<pre><code class="language-java">// 原数组：a[n]
// s[i]表示第1个点到第i个点的数组和
int[] s = new int[n+1];
// 求s[i]
for(int i = 1; i &lt;= n; i++){
	s[i] = s[i-1] + a[i-1];
}

//求[l, r]区间和, 从1开始
int sum = s[r] - s[l-1];
</code></pre>
<h4 id="二维前缀和">二维前缀和</h4>
<pre><code class="language-java">// 原矩阵：a[n][m]
// s[i][j]表示(i, j)这个点左上方的矩阵和
int[][] s = new int[n+1][m+1];
// 求s[i][j]
for(int i = 1; i &lt;= n; i++){
	for(int j = 1; j &lt;= m; j++){
		s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i-1][j-1];
	}
}

// 求左上角(x1, y1), 右下角(x2, y2)的子矩阵中所有数的和
int sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];
</code></pre>
<h4 id="一维差分">一维差分</h4>
<pre><code class="language-java">// r最大到n, r+1最大到n+1, 所以数组需要n+2的长度
int[] b = new int[n+2];

// 不用从原数组构造差分数组，可直接从0开始插入
void insert(int l, int r){
	b[l] += c;
	b[r+1] -= c;
}

// 计算前缀和, 获得处理之后的原数组
for(int i = 1; i &lt;= n; i++){
	b[i] += b[i-1];
}
</code></pre>
<h4 id="二维差分">二维差分</h4>
<pre><code class="language-java">int[][] b = new int[n+2][m+2];

void insert(int x1, int y1, int x2, int y2, int c){
    b[x1][y1] += c;
    b[x2+1][y1] -= c;
    b[x1][y2+1] -= c;
    b[x2+1][y2+1] += c;
}

// 计算前缀和, 获得处理之后的原数组
for(int i = 1; i &lt;= n; i++){
	for(int j = 1; j &lt;= m; j++){
		b[i][j] += b[i-1][j] + b[i][j-1] - s[i-1][j-1];
	}
}
</code></pre>
<h3 id="进制转换">进制转换</h3>
<h4 id="10进制转其他进制">10进制转其他进制</h4>
<ul>
<li>短除法</li>
</ul>
<pre><code class="language-java">char intToChar(int x){
    if(x &lt;= 9) return (char)(x + '0');
    return (char)(x - 10 + 'A');
}

String base(int x, int b){
    StringBuilder num = new StringBuilder();
    while(x &gt; 0){
        num.append(intToChar(x % b));
        x /= b;
    }
    return num.reverse().toString();
}
</code></pre>
<h4 id="其他进制转10进制">其他进制转10进制</h4>
<pre><code class="language-java">int charToInt(char x){
    if(x &lt;= '9') return x - '0';
    return x - 'A' + 10;
}

int base10(String x, int b){
    int res = 0;
    for(char c: x.toCharArray()){
        res = res * b + charToInt(c);
    }
    return res;
}
</code></pre>
<h3 id="并查集">并查集</h3>
<pre><code class="language-java">class UF{
    int[] p; // p[i]表示i的父节点
    int[] size; // size[i]表示i这个节点所在的连通块中的节点数目（只有根节点的size有意义）
    int cnt; // 并查集中的连通块数目

    //初始化
    public UF(int n){
        cnt = n;
        for(int i = 0; i &lt; n; i++){
            p[i] = i;
            size[i] = 1;
        }
    }

    int find(int x){
        if(x != p[x]) p[x] = find(p[x]);
        return p[x];
    }

    boolean union(int x, int y){
        int a = find(x), b = find(y);
        if(a == b) return false;
        p[a] = b;
        size[b] += size[a];
        cnt--;
        return true;
    }
}    
</code></pre>
<h3 id="最短路">最短路</h3>
<ul>
<li>建图</li>
</ul>
<pre><code class="language-java">Map&lt;Integer,List&lt;int[]&gt;&gt; g = new HashMap&lt;&gt;();
for(int[] e: edges){
    int a = e[0], b = e[1], c = e[2];
    g.computeIfAbsent(a, k -&gt; new ArrayList&lt;&gt;()).add(new int[]{b, c});
    g.computeIfAbsent(b, k -&gt; new ArrayList&lt;&gt;()).add(new int[]{a, c});
}
</code></pre>
<h4 id="dijkstra">Dijkstra</h4>
<ul>
<li>堆优化版Dijkstra</li>
</ul>
<pre><code class="language-java">// u为起点
// 跑一遍Dijkstra之后可以求出所有点到u的最短路径
void dijkstra(int u){
    Arrays.fill(dist, Integer.MAX_VALUE);
    Arrays.fill(st, false);
    dist[u] = 0;
    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1,o2) -&gt; o1[0]-o2[0]);
    //第一个值是距离源点的距离，第二个值是节点的编号
    pq.offer(new int[]{0, u});
    while(!pq.isEmpty()){
        int[] t = pq.poll();
        int v = t[1];
        if(st[v]) continue;
        st[v] = true;
        for(int[] next: g.get(v)){
            int nv = next[0];
            int w = next[1];
            if(dist[nv] &gt; dist[v] + w){
                dist[nv] = dist[v] + w;
                pq.offer(new int[]{dist[nv], nv});
            }
        }
    }
}
</code></pre>
<h3 id="数组处理">数组处理</h3>
<h4 id="原地哈希情形1求缺失的第一个正数">原地哈希情形1：求缺失的第一个正数</h4>
<pre><code class="language-c++">int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    for(int i = 0; i &lt; n; i++){
        while(nums[i] &gt;= 1 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]-1]){
            swap(nums[i], nums[nums[i]-1]);
        }
    }
    for(int i = 0; i &lt; n; i++){
        if(nums[i] != i + 1) return i + 1;
    }
    return n + 1;
}
</code></pre>
<h4 id="原地哈希情形2求数组中消失的数字范围1-n">原地哈希情形2：求数组中消失的数字，范围[1, n]</h4>
<pre><code class="language-c++">vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; res;
    for(int i = 0; i &lt; n; i++){
        while(nums[i] != nums[nums[i]-1]){
            swap(nums[i], nums[nums[i]-1]);
        }
    } 
    for(int i = 0; i &lt; n; i++){
        if(nums[i] != i + 1) res.push_back(i + 1);
    }
    return res;
}
</code></pre>
<h4 id="原地哈希情形3求数组中重复的数字范围1-n">原地哈希情形3：求数组中重复的数字，范围[1, n]</h4>
<pre><code class="language-c++">vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; res;
    for(int i = 0; i &lt; n; i++){
        while(nums[i] != nums[nums[i]-1]){
            swap(nums[i], nums[nums[i]-1]);
        }
    }
    for(int i = 0; i &lt; n; i++){
        if(nums[i] != i + 1) res.push_back(nums[i]);
    }
    return res;
}
</code></pre>
<h4 id="删除有序数组中的重复项">删除有序数组中的重复项</h4>
<pre><code class="language-java">// 删除有序数组中的重复元素，使得每个元素最多出现u次
int remove(int[] nums, int u){
    int n = nums.length;
    int k = 0;
    for(int i = 0; i &lt; n; i++){
        if(i &lt; u || nums[k - u] != nums[i]){
            nums[k++] = nums[i];
        }
    }
    return k;
}
</code></pre>
]]></content>
    </entry>
</feed>