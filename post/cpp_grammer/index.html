<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C++语法整理 | Gridea</title>
<link rel="shortcut icon" href="https://Ryan-ovo.github.io/favicon.ico?v=1618311196891">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Ryan-ovo.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C++语法整理 | Gridea - Atom Feed" href="https://Ryan-ovo.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="第一章.变量、输入输出、表达式和顺序语句
1.1 变量


bool false/true 1byte


char 'c', 'a', ' ', ' \n' 1byte


int -2147483648 ~ 2147483647 (-2..." />
    <meta name="keywords" content="C++" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Ryan-ovo.github.io">
  <img class="avatar" src="https://Ryan-ovo.github.io/images/avatar.png?v=1618311196891" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Ryan-ovo" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              C++语法整理
            </h2>
            <div class="post-info">
              <span>
                2021-04-13
              </span>
              <span>
                21 min read
              </span>
              
                <a href="https://Ryan-ovo.github.io/tag/pJgJnv3-b/" class="post-tag">
                  # C++
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="第一章变量-输入输出-表达式和顺序语句">第一章.变量、输入输出、表达式和顺序语句</h3>
<h4 id="11-变量">1.1 变量</h4>
<ul>
<li>
<p>bool false/true 1byte</p>
</li>
<li>
<p>char 'c', 'a', ' ', ' \n' 1byte</p>
</li>
<li>
<p>int -2147483648 ~ 2147483647 (-2^31 ~ 2^31-1) 4byte</p>
</li>
<li>
<p>float 1.23, 2.5, 1.235e2, 6-7位有效数字 4byte</p>
</li>
<li>
<p>double 15-16位有效数字 8bype</p>
</li>
<li>
<p>long long (-2^63 ~ 2^63-1) btype</p>
</li>
<li>
<p>long double 16bype</p>
</li>
<li>
<p>字节1B = 8bit</p>
</li>
<li>
<p>带宽8Mb = 下载速度1MB/s</p>
</li>
</ul>
<pre><code class="language-c++">int a, b = 2, c = b;
float d = 1.5, e = 1, f = 1.235e2;
bool g = true, h = false;
char j = 'a', k = 'b';
long long l = 10000000000000000000ll;// 大小写l/L均可，不写默认为整型，超过2^31-1可能变为负数
long double m = 123.45
</code></pre>
<h4 id="12输入输出">1.2输入输出</h4>
<ul>
<li>scanf, printf在头文件cstdio中</li>
</ul>
<pre><code class="language-c++">#include &lt;cstdio&gt;

using namespace std;

int main(){
    float a, b;
    // int对应%d, 不会读入空格
    // char对应%c, 会读入空格
    // float对应%f, 默认保留6位小数
    // double对应%lf, 默认保留6位小数
    // long long对应%lld
    // bool被当作整数来处理
    scanf(&quot;%f%f&quot;, &amp;a, &amp;b);
    printf(&quot;a + b = %.2f\na * b = %.3f\n&quot;, a+b, a*b);
    printf(&quot;%5d\n&quot;, 123);
    printf(&quot;%-5d\n&quot;, 123);
    printf(&quot;%05d\n&quot;, 123);
    printf(&quot;%5.2lf&quot;, 1.2);
}
</code></pre>
<ul>
<li>cin, cout, endl在头文件iostream中</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int main(){
    int a, b;
    // cin会自动过滤空格，输入中可以含有大量空格
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a+b &lt;&lt; endl;
}
</code></pre>
<h4 id="13-表达式">1.3 表达式</h4>
<ul>
<li>取模运算的结果正负取决于第一个数的正负</li>
</ul>
<pre><code class="language-c++">cout &lt;&lt; 5 % 2 &lt;&lt; endl;
cout &lt;&lt; -5 % 2 &lt;&lt; endl;
cout &lt;&lt; -5 % -2 &lt;&lt; endl;
</code></pre>
<ul>
<li>变量类型转换</li>
</ul>
<pre><code>int 可以和 float, double相互转换, 其中float, double转为int为下取整
int 可以和char相互转换，通过ASCII码表

运算会让低精度向高精度转换
int和float, double做运算 结果会转换为float, double类型
char和int做运算，结果会转换为int //A + 2 = 67, (char)(A + 2) = C
int和long long做运算，结果会转换为long long
float和double做运算，结果会转换为double
</code></pre>
<h3 id="第二章判断结构">第二章.判断结构</h3>
<ul>
<li>判断闰年</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int year;
    cin &gt;&gt; year;
    if(year % 100 == 0){
        if(year % 400 == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }else{
        if(year % 4 == 0) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
        else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<ul>
<li>逻辑运算符简化</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int year;
    cin &gt;&gt; year;
    // &amp;&amp;的优先级比||高, 不用加括号
    if(year % 400 == 0 || year % 100 != 0 &amp;&amp; year % 4 == 0){
        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
    }else{
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="第三章循环结构">第三章.循环结构</h3>
<ul>
<li>循环结构语法和Java一模一样</li>
</ul>
<pre><code class="language-c++">// while循环
while(){

}

// do-while循环
do{

}while();

// for循环
for(int i = 0; i &lt; n; i++){

}

// 控制语句
break;
continue;
</code></pre>
<ul>
<li>奇数矩阵打印菱形</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main(){
    int n;
    cin &gt;&gt; n;
    int cx = n/2, cy = n/2;
    for(int i = 0; i &lt; n; i++){
        for(int j = 0; j &lt; n; j++){
            if(abs(i-cx) + abs(j-cy) &lt;= n/2){
                cout &lt;&lt; &quot;*&quot;;
            }else{
                cout &lt;&lt; &quot; &quot;;
            }
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="第四章数组">第四章.数组</h3>
<h4 id="41-一维数组">4.1 一维数组</h4>
<ul>
<li>定义在函数内部的数组存储在栈空间中（局部变量），如果没有初始化则每个值都为随机数</li>
<li>定义在函数外部的数组存储在堆空间中（全局变量），默认值都为0</li>
<li>栈空间通常有大小限制，所以数组长度太大的数组局部变量，循环访问时可能发生段错误（解决方法：放到堆空间中）</li>
</ul>
<pre><code class="language-c++">// 定义了一个长度为3的数组
int a[3] = {0, 1, 2};
// 定义了一个长度为3的数组，长度由编译器计算
int b[] = {0, 1, 2};
// 定义了一个长度为5的数组，没有给出的值默认为0，等价于{0, 1, 2, 0, 0}
int c[5] = {0, 1, 2};
// 定义了一个长度为3的字符数组
char d[] = {'a', 'b', 'c'};
// 将数组全部初始化为0的写法
int f[100] = {0};
</code></pre>
<ul>
<li>将长度为n的数组顺时针旋转k次</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt; //reverse函数在algorithm库中
using namespace std;

int a[100];

int main(){
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
    // reverse(数组的起始位置, 数组的终止位置的下一个位置)
    reverse(a, a + n);
    reverse(a, a + k);
    reverse(a + k, a + n);
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    return 0;
}
</code></pre>
<ul>
<li>memset函数</li>
</ul>
<pre><code class="language-c++">// 为数组进行初始化，按字节赋值
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main(){
    int a[10], b[10], c[10];
    // int变量占4字节, 长度为10的int数组占40字节
    // memset按字节赋值, 一个字节有8个bit位, 把8bit位全部置为第二个参数
    // memset(a, 5, sizeof a)表示把每8bit都置为00000101
    memset(a, 0, 40);
    // sizeof为运算符, 可以计算出数组一共占多少字节
    memset(a, 0, sizeof a);
    // 只有0和-1初始化完恰好数组为全0或者全-1
    memset(b, -1, sizeof b);
    // 0x3f3f3f3f是一个非常大的数，其两倍都不会超出int的范围，常用于初始化一个很大的值
    memset(c, 0x3f, sizeof c);
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; c[i] &lt;&lt; ' ';
    return 0;
}

</code></pre>
<ul>
<li>memcpy函数在</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

int main(){
    int a[10], b[10];
    for(int i = 0; i &lt; 10; i++) a[i] = i;
    memcpy(b, a, sizeof a);
    for(int i = 0; i &lt; 10; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    return 0;
}
</code></pre>
<h4 id="42-二维数组">4.2 二维数组</h4>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int main(){
    // 每一维都是一维数组，都可以按一维数组来初始化
    // {{1, 2, 3, 4}, {1, 0, 0, 0}, {1, 0, 0, 0}} 不足补零
    int a[3][4] = {{1, 2, 3, 4}, {1}, {1}};  
    for(int i = 0; i &lt; 3; i++){
        for(int j = 0; j &lt; 4; j++){
            cout &lt;&lt; a[i][j] &lt;&lt; ' ';
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<ul>
<li>多维数组可以实现，只要不超内存限制即可</li>
<li>二十维的数组，每一维的长度为2，能存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>个数</li>
</ul>
<h3 id="第七章类-结构体-指针-引用">第七章.类 结构体 指针 引用</h3>
<h4 id="类">类</h4>
<ul>
<li>类可以把变量，数组，函数等打包到一起使用</li>
<li>类中不写修饰符默认为private</li>
<li>构造函数写法1：</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person{
    private:
        int age, height;
        double money;
    public:
        Person(){}
        Person(int _age, int _height, double _money){
            age = _age;
            height = _height;
            money = _money;
        }
        string name;
        void say(){
            cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
        }
        int get_age(){
            return age;
        }
        void add_money(int x){
            money += x;
        }
};

int main(){
    Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    p.age = 18; // 无法访问私有变量
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>构造函数写法2：</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person{
    private:
        int age, height;
        double money;
    public:
        Person(){}
        Person(int _age, int _height, double _money): age(_age), height(_height), money(_money){}
        string name;
        void say(){
            cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
        }
        int get_age(){
            return age;
        }
        void add_money(int x){
            money += x;
        }
};

int main(){
    Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    // p.age = 18; // 无法访问私有变量
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="结构体">结构体</h4>
<ul>
<li>结构体和类的作用相同，但是结构体用来存储相对简单的数据捆绑类型，类用来存储相对复杂，逻辑混乱的各类数据</li>
<li>结构体中修饰符不写默认为public</li>
<li>写法和类几乎一样</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

struct Person{
    int age, height;
    double money;
    string name;

    Person(){}
    Person(int _age, int _height, double _money): age(_age), height(_height), money(_money){}
    
    void say(){
        cout &lt;&lt; &quot;I'm &quot; &lt;&lt; name &lt;&lt; endl;
    }
    int get_age(){
        return age;
    }
    void add_money(int x){
        money += x;
    }
};

int main(){
    Person p = {18, 180, 0};
    // Person p(18, 180, 0);
    p.name = &quot;zhangsan&quot;;
    p.age = 18;
    p.add_money(10000);
    cout &lt;&lt; p.name &lt;&lt; endl;
    cout &lt;&lt; p.get_age() &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="第八章stl">第八章.STL</h3>
<h4 id="pair">pair</h4>
<ul>
<li>二元组，泛型确定数据类型</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(){
    pair&lt;int,string&gt; a;
    // 初始化
    a = {1, &quot;aaa&quot;};
    a = make_pair(2, &quot;bbb&quot;);
    cout &lt;&lt; a.first &lt;&lt; ' ' &lt;&lt; a.second &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="vector">vector</h4>
<ul>
<li>定义与初始化</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    // 初始化为给定的值
    vector&lt;int&gt; a({1, 2, 3});
    // 初始化二维vector, 并赋初值为1
    vector&lt;vector&lt;int&gt;&gt; b(3, vector&lt;int&gt;(4, 1));
    // 定义长度为5的vector, 默认值都为0
    vector&lt;int&gt; c(5);
    // 定义长度为5的vector, 并赋初值为1
    vector&lt;int&gt; d(5, 1);
    return 0;
}
</code></pre>
<ul>
<li>遍历</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; a({1, 2, 3});
    // 类似数组
    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    //迭代器(一般不用)
    for(vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(auto i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(auto i = a.begin(); i &lt; a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    // for-each
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    return 0;
}
</code></pre>
<ul>
<li>常用函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
    vector&lt;int&gt; a({1, 2, 3});
    // 遍历
    for(int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    for(auto i = a.begin(); i != a.end(); i++) cout &lt;&lt; *i &lt;&lt; ' ';
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    
    // 数组长度
    cout &lt;&lt; a.size() &lt;&lt; endl;
    // 判空
    cout &lt;&lt; a.empty() &lt;&lt; endl;
    // 清空vector
    a.clear();
    // front(): 取出第一个元素
    // back(): 取出最后一个元素
    // rbegin(): 反向迭代器，指向最后一个元素
    // rend(): 反向迭代器，指向第一个元素的前一个元素
    // [begin(), end()) 前闭后开
    cout &lt;&lt; a.front() &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; *a.begin() &lt;&lt; ' ' &lt;&lt; *(a.rend()-1) &lt;&lt; endl;
    cout &lt;&lt; a.back() &lt;&lt; ' ' &lt;&lt; a[a.size()-1] &lt;&lt; ' ' &lt;&lt; *(a.end()-1) &lt;&lt; ' ' &lt;&lt; *a.rbegin() &lt;&lt; endl;
    // 往最后插入元素
    a.push_back(4);
    // 删除最后一个元素
    a.pop_back();
    
    // resize(n): 调整容器的大小, 使其包含n个元素
    // 如果n比原来长度小, 则保留前n个元素, 如果n比原来长度大, 则用0补齐
    // resize(n, v): 调整容器大小为n, 补齐的部分初始化为-1
    a.resize(10);
    // 1 2 3 0 0 0 0 0 0 0 
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    a.resize(2);
    // 1 2 
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    a.resize(5, -1);
    // 1 2 -1 -1 -1
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h4 id="queue">queue</h4>
<ul>
<li>头文件queue中含有queue, priority_queue</li>
<li>队列和栈都没有clear函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    // 大根堆
    priority_queue&lt;int&gt; a;
    // 小根堆
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; b;
    // 二元组大根堆
    priority_queue&lt;pair&lt;int, int&gt;&gt; c;
    
    // queue没有clear()函数，清空重新定义一遍即可、
    q = queue&lt;int&gt;();

    struct Rec{
        int a, b;
        bool operator&gt; (const Rec&amp; t) const{
            return a &gt; t.a;
        }
    };
    // 堆中存放结构体: 大根堆重载小于号, 小根堆重载大于号
    priority_queue&lt;Rec, vector&lt;Rec&gt;, greater&lt;Rec&gt;&gt; d;
    d.push({1, 2});
    d.push({-1, 1});
    // -1
    cout &lt;&lt; d.top().a &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>常用方法</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

int main(){
    queue&lt;int&gt; q;
    q.push(1); // 队尾插入元素
    q.pop(); // 队头删除元素
    cout &lt;&lt; q.size() &lt;&lt; endl; // 队列大小
    cout &lt;&lt; q.front() &lt;&lt; endl; // 队头元素
    cout &lt;&lt; q.back() &lt;&lt; endl; // 队尾元素
    // 大根堆
    priority_queue&lt;int&gt; a;
    a.push(1); // 堆中插入元素
    a.pop(); // 删除堆顶元素
    cout &lt;&lt; a.top() &lt;&lt; endl; // 获取堆顶元素
    return 0;
}
</code></pre>
<h4 id="stack">stack</h4>
<ul>
<li>栈：先进后出</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

int main(){
    stack&lt;int&gt; stk;
    stk.push(1); // 压栈
    stk.pop(); // 弹出栈顶元素
    stk.top(); // 获取栈顶元素
}
</code></pre>
<h3 id="deque">deque</h3>
<ul>
<li>头文件：deque</li>
<li>双端队列：加强版的vector</li>
</ul>
<pre><code class="language-c++">#include &lt;deque&gt;
using namespace std;
int main(){
    deque&lt;int&gt; a;
    // 迭代器
    a.begin(), a.end();
    a.front(), a.back();
    // 常用函数
    a.push_back(1), a.push_front(2);
    a[0];
    a.pop_back(), a.pop_front();
    return 0;
}
</code></pre>
<h3 id="set">set</h3>
<ul>
<li>头文件：set, unordered_set</li>
<li>set：有序集合（元素不能重复）</li>
<li>multiset：有序多重集合（元素可以重复）</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;unordered_set&gt;
using namespace std;
int main(){
    set&lt;int&gt; a;
    multiset&lt;int&gt; b;

    set&lt;int&gt;::iterator it = a.begin();
    it++; it--;
    ++it; --it;
    a.end();

    a.insert(x);
    if(a.find(x) == a.end()) //判断x在a中是否存在

    a.erase(x); // 删除所有值为x的迭代器
    a.erase(it); // 删除it这个迭代器

    a.lower_bound(x); // 找到大于等于x的最小元素的迭代器, 并返回迭代器
    a.upper_bound(x); // 找到大于x的最小元素的迭代器, 并返回迭代器

    a.count(x); // x在a中出现了几次, set只有0和1两个值
    return 0;
}   
</code></pre>
<h4 id="map">map</h4>
<ul>
<li>头文件：map, unordered_map</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
using namespace std;
int main(){
    map&lt;int, int&gt; a;
    a[1] = 2;
    a[2] = 3;
    a.insert({3, 4});
    a.erase(3);
    for (auto&amp; [k, v]: a){
        cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; v &lt;&lt; endl;
    }
    
    for(auto&amp; item: a){
        cout &lt;&lt; item.first &lt;&lt; ' ' &lt;&lt; item.second &lt;&lt; endl;
    }
    
    for(map&lt;int, int&gt;::iterator it = a.begin(); it != a.end(); it++){
        cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
}
</code></pre>
<h4 id="bitset">bitset</h4>
<ul>
<li>头文件：bitset</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;bitset&gt;
using namespace std;
int main(){
    // 实际上存储的是二进制串，可以用于位运算
    // &lt;&gt;内表示的是二进制串的长度
    bitset&lt;1000&gt; a, b;
    a[0] = 1; // 第0位设为1
    b[1] = 1; // 第1位设为1
    a &amp;= b; 
    a |= b;
    cout &lt;&lt; a &lt;&lt; endl; //打印位运算后的结果
    a.set(3); // 第3位设为1
    a.reset(3); // 第3位设为0 
    cout &lt;&lt; a[3] &lt;&lt; endl; // 查看第3位是0还是1
    return 0;
}
</code></pre>
<h3 id="常用函数">常用函数</h3>
<h4 id="unique">unique</h4>
<ul>
<li>unique()：去重数组或者容器，返回去重后数组的最后一个位置下一个位置的指针或迭代器</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int a[7] = {1, 1, 2, 3, 3, 4, 4};
    vector&lt;int&gt; b({1, 1, 2, 3, 3, 4, 4});
    vector&lt;int&gt; c({1, 1, 2, 3, 3, 4, 4});
    // 返回去重后的数组长度
    int n = unique(a, a + 7) - a;
    cout &lt;&lt; n &lt;&lt; endl;
    for(int i = 0; i &lt; n; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    int m = unique(b.begin(), b.end()) - b.begin();
    for(int i = 0; i &lt; m; i++) cout &lt;&lt; b[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // erase()：移除从两个迭代器中间的所有元素
    c.erase(unique(c.begin(), c.end()), c.end());
    for(int x: c) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    return 0;
}
</code></pre>
<h4 id="random_shuffle">random_shuffle</h4>
<ul>
<li>random_shuffle()：随机打乱数组</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;
using namespace std;
int main(){
    vector&lt;int&gt; a({1, 2, 3, 4, 5});
    srand(time(0));
    random_shuffle(a.begin(), a.end());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    return 0;
}
</code></pre>
<h4 id="sort">sort</h4>
<ul>
<li>给数组/可变数组排序</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

bool cmp(int a, int b){
    // a是否排在b前面
    return a &gt; b;
}

int main(){
    vector&lt;int&gt; a({2, 4, 1, 5, 3});
    // 默认从小到大排序
    sort(a.begin(), a.end());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // 从大到小排序, 写法一：传参
    sort(a.begin(), a.end(), greater&lt;int&gt;());
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    
    // 从大到小排序, 写法二：传入比较函数
    sort(a.begin(), a.end(), cmp);
    for(int x: a) cout &lt;&lt; x &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>给结构体数组排序：定义比较函数</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

struct Rec{
    int x, y;
}q[5];

bool cmp(Rec a, Rec b){
    // a是否排在b前面
    return a.x + a.y &gt; b.x + b.y;
}

int main(){
    for(int i = 0; i &lt; 5; i++){
        q[i].x = i;
        q[i].y = i &lt;&lt; 1;
    }
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    
    sort(q, q + 5, cmp);
    
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>给结构体数组排序：重载小于号</li>
</ul>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

struct Rec{
    int x, y;
    bool operator&lt;(const Rec&amp; t) const{
        return x + y &gt; t.x + t.y;
    }
}q[5];


int main(){
    for(int i = 0; i &lt; 5; i++){
        q[i].x = i;
        q[i].y = i &lt;&lt; 1;
    }
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    
    sort(q, q + 5);
    
    for(int i = 0; i &lt; 5; i++){
        printf(&quot;(%d,%d) &quot;, q[i].x, q[i].y);
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%8F%98%E9%87%8F-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%AF%AD%E5%8F%A5">第一章.变量、输入输出、表达式和顺序语句</a>
<ul>
<li><a href="#11-%E5%8F%98%E9%87%8F">1.1 变量</a></li>
<li><a href="#12%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">1.2输入输出</a></li>
<li><a href="#13-%E8%A1%A8%E8%BE%BE%E5%BC%8F">1.3 表达式</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84">第二章.判断结构</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">第三章.循环结构</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%95%B0%E7%BB%84">第四章.数组</a>
<ul>
<li><a href="#41-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84">4.1 一维数组</a></li>
<li><a href="#42-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">4.2 二维数组</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8">第七章.类 结构体 指针 引用</a>
<ul>
<li><a href="#%E7%B1%BB">类</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0stl">第八章.STL</a>
<ul>
<li><a href="#pair">pair</a></li>
<li><a href="#vector">vector</a></li>
<li><a href="#queue">queue</a></li>
<li><a href="#stack">stack</a></li>
</ul>
</li>
<li><a href="#deque">deque</a></li>
<li><a href="#set">set</a>
<ul>
<li><a href="#map">map</a></li>
<li><a href="#bitset">bitset</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a>
<ul>
<li><a href="#unique">unique</a></li>
<li><a href="#random_shuffle">random_shuffle</a></li>
<li><a href="#sort">sort</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Ryan-ovo.github.io/post/leetcode-ti-xing-zong-jie/">
              <h3 class="post-title">
                LeetCode题型总结
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://Ryan-ovo.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
